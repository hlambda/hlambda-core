{"version":3,"sources":["out-vscode-web/vs/workbench/contrib/notebook/common/services/fake","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/stream.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/buffer.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/editor/common/core/eolCounter.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/mime.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/map.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/network.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/resources.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/async.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/base/common/glob.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/editor/common/core/stringBuilder.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/editor/common/core/textChange.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/platform/instantiation/common/instantiation.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/workbench/contrib/notebook/common/notebookCommon.ts","out-vscode-web/vs/workbench/contrib/notebook/common/services/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/workbench/contrib/notebook/common/services/notebookSimpleWorker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): IDisposable {\n\tlet destroyed = false;\n\n\tstream.on('error', error => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n\n\treturn toDisposable(() => destroyed = true);\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Piece, PieceTreeBase } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\n\nexport class TreeNode {\n\tparent: TreeNode;\n\tleft: TreeNode;\n\tright: TreeNode;\n\tcolor: NodeColor;\n\n\t// Piece\n\tpiece: Piece;\n\tsize_left: number; // size of the left subtree (not inorder)\n\tlf_left: number; // line feeds cnt in the left subtree (not in order)\n\n\tconstructor(piece: Piece, color: NodeColor) {\n\t\tthis.piece = piece;\n\t\tthis.color = color;\n\t\tthis.size_left = 0;\n\t\tthis.lf_left = 0;\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t}\n\n\tpublic next(): TreeNode {\n\t\tif (this.right !== SENTINEL) {\n\t\t\treturn leftest(this.right);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.left === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic prev(): TreeNode {\n\t\tif (this.left !== SENTINEL) {\n\t\t\treturn righttest(this.left);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nexport const SENTINEL: TreeNode = new TreeNode(null!, NodeColor.Black);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = NodeColor.Black;\n\nexport function leftest(node: TreeNode): TreeNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nexport function righttest(node: TreeNode): TreeNode {\n\twhile (node.right !== SENTINEL) {\n\t\tnode = node.right;\n\t}\n\treturn node;\n}\n\nexport function calculateSize(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.size_left + node.piece.length + calculateSize(node.right);\n}\n\nexport function calculateLF(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\n\nexport function resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n}\n\nexport function leftRotate(tree: PieceTreeBase, x: TreeNode) {\n\tconst y = x.right;\n\n\t// fix size_left\n\ty.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\tx.right = y.left;\n\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\n\tif (x.parent === SENTINEL) {\n\t\ttree.root = y;\n\t} else if (x.parent.left === x) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\ty.left = x;\n\tx.parent = y;\n}\n\nexport function rightRotate(tree: PieceTreeBase, y: TreeNode) {\n\tconst x = y.left;\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\n\t// fix size_left\n\ty.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\n\tif (y.parent === SENTINEL) {\n\t\ttree.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n}\n\nexport function rbDelete(tree: PieceTreeBase, z: TreeNode) {\n\tlet x: TreeNode;\n\tlet y: TreeNode;\n\n\tif (z.left === SENTINEL) {\n\t\ty = z;\n\t\tx = y.right;\n\t} else if (z.right === SENTINEL) {\n\t\ty = z;\n\t\tx = y.left;\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\t}\n\n\tif (y === tree.root) {\n\t\ttree.root = x;\n\n\t\t// if x is null, we are removing the only node\n\t\tx.color = NodeColor.Black;\n\t\tz.detach();\n\t\tresetSentinel();\n\t\ttree.root.parent = SENTINEL;\n\n\t\treturn;\n\t}\n\n\tconst yWasRed = (y.color === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t\trecomputeTreeMetadata(tree, x);\n\t} else {\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\t// as we make changes to x's hierarchy, update size_left of subtree first\n\t\trecomputeTreeMetadata(tree, x);\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\ty.color = z.color;\n\n\t\tif (z === tree.root) {\n\t\t\ttree.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t\t// update metadata\n\t\t// we replace z with y, so in this sub tree, the length change is z.item.length\n\t\ty.size_left = z.size_left;\n\t\ty.lf_left = z.lf_left;\n\t\trecomputeTreeMetadata(tree, y);\n\t}\n\n\tz.detach();\n\n\tif (x.parent.left === x) {\n\t\tconst newSizeLeft = calculateSize(x);\n\t\tconst newLFLeft = calculateLF(x);\n\t\tif (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n\t\t\tconst delta = newSizeLeft - x.parent.size_left;\n\t\t\tconst lf_delta = newLFLeft - x.parent.lf_left;\n\t\t\tx.parent.size_left = newSizeLeft;\n\t\t\tx.parent.lf_left = newLFLeft;\n\t\t\tupdateTreeMetadata(tree, x.parent, delta, lf_delta);\n\t\t}\n\t}\n\n\trecomputeTreeMetadata(tree, x.parent);\n\n\tif (yWasRed) {\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: TreeNode;\n\twhile (x !== tree.root && x.color === NodeColor.Black) {\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (w.right.color === NodeColor.Black) {\n\t\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\trightRotate(tree, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (w.left.color === NodeColor.Black) {\n\t\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\tleftRotate(tree, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t}\n\t}\n\tx.color = NodeColor.Black;\n\tresetSentinel();\n}\n\nexport function fixInsert(tree: PieceTreeBase, x: TreeNode) {\n\trecomputeTreeMetadata(tree, x);\n\n\twhile (x !== tree.root && x.parent.color === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(tree, x);\n\t\t\t\t}\n\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(tree, x);\n\t\t\t\t}\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\ttree.root.color = NodeColor.Black;\n}\n\nexport function updateTreeMetadata(tree: PieceTreeBase, x: TreeNode, delta: number, lineFeedCntDelta: number): void {\n\t// node length change or line feed count change\n\twhile (x !== tree.root && x !== SENTINEL) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lineFeedCntDelta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n\nexport function recomputeTreeMetadata(tree: PieceTreeBase, x: TreeNode) {\n\tlet delta = 0;\n\tlet lf_delta = 0;\n\tif (x === tree.root) {\n\t\treturn;\n\t}\n\n\t// go upwards till the node whose left subtree is changed.\n\twhile (x !== tree.root && x === x.parent.right) {\n\t\tx = x.parent;\n\t}\n\n\tif (x === tree.root) {\n\t\t// well, it means we add a node to the end (inorder)\n\t\treturn;\n\t}\n\n\t// x is the node whose right subtree is changed.\n\tx = x.parent;\n\n\tdelta = calculateSize(x.left) - x.size_left;\n\tlf_delta = calculateLF(x.left) - x.lf_left;\n\tx.size_left += delta;\n\tx.lf_left += lf_delta;\n\n\n\t// go upwards till root. O(logN)\n\twhile (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lf_delta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { extname } from 'vs/base/common/path';\n\nexport const Mimes = Object.freeze({\n\ttext: 'text/plain',\n\tbinary: 'application/octet-stream',\n\tunknown: 'application/unknown',\n\tmarkdown: 'text/markdown',\n\tlatex: 'text/latex',\n\turiList: 'text/uri-list',\n});\n\ninterface MapExtToMediaMimes {\n\t[index: string]: string;\n}\n\nconst mapExtToTextMimes: MapExtToMediaMimes = {\n\t'.css': 'text/css',\n\t'.csv': 'text/csv',\n\t'.htm': 'text/html',\n\t'.html': 'text/html',\n\t'.ics': 'text/calendar',\n\t'.js': 'text/javascript',\n\t'.mjs': 'text/javascript',\n\t'.txt': 'text/plain',\n\t'.xml': 'text/xml'\n};\n\n// Known media mimes that we can handle\nconst mapExtToMediaMimes: MapExtToMediaMimes = {\n\t'.aac': 'audio/x-aac',\n\t'.avi': 'video/x-msvideo',\n\t'.bmp': 'image/bmp',\n\t'.flv': 'video/x-flv',\n\t'.gif': 'image/gif',\n\t'.ico': 'image/x-icon',\n\t'.jpe': 'image/jpg',\n\t'.jpeg': 'image/jpg',\n\t'.jpg': 'image/jpg',\n\t'.m1v': 'video/mpeg',\n\t'.m2a': 'audio/mpeg',\n\t'.m2v': 'video/mpeg',\n\t'.m3a': 'audio/mpeg',\n\t'.mid': 'audio/midi',\n\t'.midi': 'audio/midi',\n\t'.mk3d': 'video/x-matroska',\n\t'.mks': 'video/x-matroska',\n\t'.mkv': 'video/x-matroska',\n\t'.mov': 'video/quicktime',\n\t'.movie': 'video/x-sgi-movie',\n\t'.mp2': 'audio/mpeg',\n\t'.mp2a': 'audio/mpeg',\n\t'.mp3': 'audio/mpeg',\n\t'.mp4': 'video/mp4',\n\t'.mp4a': 'audio/mp4',\n\t'.mp4v': 'video/mp4',\n\t'.mpe': 'video/mpeg',\n\t'.mpeg': 'video/mpeg',\n\t'.mpg': 'video/mpeg',\n\t'.mpg4': 'video/mp4',\n\t'.mpga': 'audio/mpeg',\n\t'.oga': 'audio/ogg',\n\t'.ogg': 'audio/ogg',\n\t'.opus': 'audio/opus',\n\t'.ogv': 'video/ogg',\n\t'.png': 'image/png',\n\t'.psd': 'image/vnd.adobe.photoshop',\n\t'.qt': 'video/quicktime',\n\t'.spx': 'audio/ogg',\n\t'.svg': 'image/svg+xml',\n\t'.tga': 'image/x-tga',\n\t'.tif': 'image/tiff',\n\t'.tiff': 'image/tiff',\n\t'.wav': 'audio/x-wav',\n\t'.webm': 'video/webm',\n\t'.webp': 'image/webp',\n\t'.wma': 'audio/x-ms-wma',\n\t'.wmv': 'video/x-ms-wmv',\n\t'.woff': 'application/font-woff',\n};\n\nexport function getMediaOrTextMime(path: string): string | undefined {\n\tconst ext = extname(path);\n\tconst textMime = mapExtToTextMimes[ext.toLowerCase()];\n\tif (textMime !== undefined) {\n\t\treturn textMime;\n\t} else {\n\t\treturn getMediaMime(path);\n\t}\n}\n\nexport function getMediaMime(path: string): string | undefined {\n\tconst ext = extname(path);\n\treturn mapExtToMediaMimes[ext.toLowerCase()];\n}\n\nexport function getExtensionForMimeType(mimeType: string): string | undefined {\n\tfor (const extension in mapExtToMediaMimes) {\n\t\tif (mapExtToMediaMimes[extension] === mimeType) {\n\t\t\treturn extension;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nconst _simplePattern = /^(.+)\\/(.+?)(;.+)?$/;\n\nexport function normalizeMimeType(mimeType: string): string;\nexport function normalizeMimeType(mimeType: string, strict: true): string | undefined;\nexport function normalizeMimeType(mimeType: string, strict?: true): string | undefined {\n\n\tconst match = _simplePattern.exec(mimeType);\n\tif (!match) {\n\t\treturn strict\n\t\t\t? undefined\n\t\t\t: mimeType;\n\t}\n\t// https://datatracker.ietf.org/doc/html/rfc2045#section-5.1\n\t// media and subtype must ALWAYS be lowercase, parameter not\n\treturn `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string): string | undefined {\n\treturn hasDriveLetter(path) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tsuffix += pathChars.charAt(Math.floor(Math.random() * pathChars.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { shuffle } from 'vs/base/common/arrays';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport interface IKeyIterator<K> {\n\treset(key: K): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator<string> {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class ConfigKeysIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Period) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _valueLen!: number;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _splitOnBackslash: boolean = true,\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\tthis._value = key;\n\t\tthis._valueLen = key.length;\n\t\tfor (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n\t\t\tconst ch = this._value.charCodeAt(pos);\n\t\t\tif (!(ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._valueLen;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._valueLen; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nconst enum UriIteratorState {\n\tScheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n\tprivate _pathIterator!: PathIterator;\n\tprivate _value!: URI;\n\tprivate _states: UriIteratorState[] = [];\n\tprivate _stateIdx: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _ignorePathCasing: (uri: URI) => boolean,\n\t\tprivate readonly _ignoreQueryAndFragment: (uri: URI) => boolean) { }\n\n\treset(key: URI): this {\n\t\tthis._value = key;\n\t\tthis._states = [];\n\t\tif (this._value.scheme) {\n\t\t\tthis._states.push(UriIteratorState.Scheme);\n\t\t}\n\t\tif (this._value.authority) {\n\t\t\tthis._states.push(UriIteratorState.Authority);\n\t\t}\n\t\tif (this._value.path) {\n\t\t\tthis._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n\t\t\tthis._pathIterator.reset(key.path);\n\t\t\tif (this._pathIterator.value()) {\n\t\t\t\tthis._states.push(UriIteratorState.Path);\n\t\t\t}\n\t\t}\n\t\tif (!this._ignoreQueryAndFragment(key)) {\n\t\t\tif (this._value.query) {\n\t\t\t\tthis._states.push(UriIteratorState.Query);\n\t\t\t}\n\t\t\tif (this._value.fragment) {\n\t\t\t\tthis._states.push(UriIteratorState.Fragment);\n\t\t\t}\n\t\t}\n\t\tthis._stateIdx = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n\t\t\tthis._pathIterator.next();\n\t\t} else {\n\t\t\tthis._stateIdx += 1;\n\t\t}\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n\t\t\t|| this._stateIdx < this._states.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn compareIgnoreCase(a, this._value.scheme);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn compareIgnoreCase(a, this._value.authority);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.cmp(a);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn compare(a, this._value.query);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn compare(a, this._value.fragment);\n\t\t}\n\t\tthrow new Error();\n\t}\n\n\tvalue(): string {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn this._value.scheme;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn this._value.authority;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.value();\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn this._value.query;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn this._value.fragment;\n\t\t}\n\t\tthrow new Error();\n\t}\n}\n\nclass TernarySearchTreeNode<K, V> {\n\theight: number = 1;\n\tsegment!: string;\n\tvalue: V | undefined;\n\tkey: K | undefined;\n\tleft: TernarySearchTreeNode<K, V> | undefined;\n\tmid: TernarySearchTreeNode<K, V> | undefined;\n\tright: TernarySearchTreeNode<K, V> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n\n\trotateLeft() {\n\t\tconst tmp = this.right!;\n\t\tthis.right = tmp.left;\n\t\ttmp.left = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\trotateRight() {\n\t\tconst tmp = this.left!;\n\t\tthis.left = tmp.right;\n\t\ttmp.right = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\tupdateHeight() {\n\t\tthis.height = 1 + Math.max(this.heightLeft, this.heightRight);\n\t}\n\n\tbalanceFactor() {\n\t\treturn this.heightRight - this.heightLeft;\n\t}\n\n\tget heightLeft() {\n\t\treturn this.left?.height ?? 0;\n\t}\n\n\tget heightRight() {\n\t\treturn this.right?.height ?? 0;\n\t}\n}\n\nconst enum Dir {\n\tLeft = -1,\n\tMid = 0,\n\tRight = 1,\n}\n\nexport class TernarySearchTree<K, V> {\n\n\tstatic forUris<E>(ignorePathCasing: (key: URI) => boolean = () => false, ignoreQueryAndFragment: (key: URI) => boolean = () => false): TernarySearchTree<URI, E> {\n\t\treturn new TernarySearchTree<URI, E>(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));\n\t}\n\n\tstatic forPaths<E>(ignorePathCasing = false): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new PathIterator(undefined, !ignorePathCasing));\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new StringIterator());\n\t}\n\n\tstatic forConfigKeys<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new ConfigKeysIterator());\n\t}\n\n\tprivate _iter: IKeyIterator<K>;\n\tprivate _root: TernarySearchTreeNode<K, V> | undefined;\n\n\tconstructor(segments: IKeyIterator<K>) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\t/**\n\t * Fill the tree with the same value of the given keys\n\t */\n\tfill(element: V, keys: readonly K[]): void;\n\t/**\n\t * Fill the tree with given [key,value]-tuples\n\t */\n\tfill(values: readonly [K, V][]): void;\n\tfill(values: readonly [K, V][] | V, keys?: readonly K[]): void {\n\t\tif (keys) {\n\t\t\tconst arr = keys.slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const k of arr) {\n\t\t\t\tthis.set(k, (<V>values));\n\t\t\t}\n\t\t} else {\n\t\t\tconst arr = (<[K, V][]>values).slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const entry of arr) {\n\t\t\t\tthis.set(entry[0], entry[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key: K, element: V): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<K, V>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<K, V>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\n\t\t// find insert_node\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// set value\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\n\t\t// balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\t// needs rotate\n\t\t\t\tconst d1 = stack[i][0];\n\t\t\t\tconst d2 = stack[i + 1][0];\n\n\t\t\t\tif (d1 === Dir.Right && d2 === Dir.Right) {\n\t\t\t\t\t//right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Left) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else if (d1 === Dir.Right && d2 === Dir.Left) {\n\t\t\t\t\t// right, left -> double rotate right, left\n\t\t\t\t\tnode.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Right) {\n\t\t\t\t\t// left, right -> double rotate left, right\n\t\t\t\t\tnode.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\n\t\t\t\t// patch path to parent\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = stack[0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn oldElement;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._getNode(key)?.value;\n\t}\n\n\tprivate _getNode(key: K) {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\thas(key: K): boolean {\n\t\tconst node = this._getNode(key);\n\t\treturn !(node?.value === undefined && node?.mid === undefined);\n\t}\n\n\tdelete(key: K): void {\n\t\treturn this._delete(key, false);\n\t}\n\n\tdeleteSuperstr(key: K): void {\n\t\treturn this._delete(key, true);\n\t}\n\n\tprivate _delete(key: K, superStr: boolean): void {\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\t// node not found\n\t\t\treturn;\n\t\t}\n\n\t\tif (superStr) {\n\t\t\t// removing children, reset height\n\t\t\tnode.left = undefined;\n\t\t\tnode.mid = undefined;\n\t\t\tnode.right = undefined;\n\t\t\tnode.height = 1;\n\t\t} else {\n\t\t\t// removing element\n\t\t\tnode.key = undefined;\n\t\t\tnode.value = undefined;\n\t\t}\n\n\t\t// BST node removal\n\t\tif (!node.mid && !node.value) {\n\t\t\tif (node.left && node.right) {\n\t\t\t\t// full node\n\t\t\t\tconst min = this._min(node.right);\n\t\t\t\tconst { key, value, segment } = min;\n\t\t\t\tthis._delete(min.key!, false);\n\t\t\t\tnode.key = key;\n\t\t\t\tnode.value = value;\n\t\t\t\tnode.segment = segment;\n\n\t\t\t} else {\n\t\t\t\t// empty or half empty\n\t\t\t\tconst newChild = node.left ?? node.right;\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tconst [dir, parent] = stack[stack.length - 1];\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase Dir.Left: parent.left = newChild; break;\n\t\t\t\t\t\tcase Dir.Mid: parent.mid = newChild; break;\n\t\t\t\t\t\tcase Dir.Right: parent.right = newChild; break;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = newChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// AVL balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf > 1) {\n\t\t\t\t// right heavy\n\t\t\t\tif (node.right!.balanceFactor() >= 0) {\n\t\t\t\t\t// right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t} else {\n\t\t\t\t\t// right, left -> double rotate\n\t\t\t\t\tnode.right = node.right!.rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t}\n\n\t\t\t} else if (bf < -1) {\n\t\t\t\t// left heavy\n\t\t\t\tif (node.left!.balanceFactor() <= 0) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t} else {\n\t\t\t\t\t// left, right -> double rotate\n\t\t\t\t\tnode.left = node.left!.rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch path to parent\n\t\t\tif (i > 0) {\n\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._root = stack[0][1];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _min(node: TernarySearchTreeNode<K, V>): TernarySearchTreeNode<K, V> {\n\t\twhile (node.left) {\n\t\t\tnode = node.left;\n\t\t}\n\t\treturn node;\n\t}\n\n\tfindSubstr(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: V | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: K): IterableIterator<[K, V]> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._entries(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tforEach(callback: (value: V, index: K) => any): void {\n\t\tfor (const [key, value] of this) {\n\t\t\tcallback(value, key);\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\tyield* this._entries(this._root);\n\t}\n\n\tprivate _entries(node: TernarySearchTreeNode<K, V> | undefined): IterableIterator<[K, V]> {\n\t\tconst result: [K, V][] = [];\n\t\tthis._dfsEntries(node, result);\n\t\treturn result[Symbol.iterator]();\n\t}\n\n\tprivate _dfsEntries(node: TernarySearchTreeNode<K, V> | undefined, bucket: [K, V][]) {\n\t\t// DFS\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.left) {\n\t\t\tthis._dfsEntries(node.left, bucket);\n\t\t}\n\t\tif (node.value) {\n\t\t\tbucket.push([node.key!, node.value]);\n\t\t}\n\t\tif (node.mid) {\n\t\t\tthis._dfsEntries(node.mid, bucket);\n\t\t}\n\t\tif (node.right) {\n\t\t\tthis._dfsEntries(node.right, bucket);\n\t\t}\n\t}\n\n\t// for debug/testing\n\t_isBalanced(): boolean {\n\t\tconst nodeIsBalanced = (node: TernarySearchTreeNode<any, any> | undefined): boolean => {\n\t\t\tif (!node) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn nodeIsBalanced(node.left) && nodeIsBalanced(node.right);\n\t\t};\n\t\treturn nodeIsBalanced(this._root);\n\t}\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\tconstructor(mapOrKeyFn?: ResourceMap<T> | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (mapOrKeyFn instanceof ResourceMap) {\n\t\t\tthis.map = new Map(mapOrKeyFn.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, <any>this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: any): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n\n/**\n * Wraps the map in type that only implements readonly properties. Useful\n * in the extension host to prevent the consumer from making any mutations.\n */\nexport class ReadonlyMapView<K, V> implements ReadonlyMap<K, V>{\n\treadonly #source: ReadonlyMap<K, V>;\n\n\tpublic get size() {\n\t\treturn this.#source.size;\n\t}\n\n\tconstructor(source: ReadonlyMap<K, V>) {\n\t\tthis.#source = source;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void, thisArg?: any): void {\n\t\tthis.#source.forEach(callbackfn, thisArg);\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this.#source.get(key);\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this.#source.has(key);\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\treturn this.#source.entries();\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this.#source.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this.#source.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.#source.entries();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebook = 'vscode-notebook';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractive = 'vscode-interactive';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(uri: URI): URI;\n\tasBrowserUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasBrowserUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(uri: URI): URI;\n\tasFileUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasFileUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl!.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises is resolved and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst result = await Promise.race(promises);\n\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\tif (index !== resolvedPromiseIndex) {\n\t\t\tcancellablePromise.cancel();\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/** Can be passed into the Delayed to defer using a microtask */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tEvent.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tthis.pendingWork.push(...units);\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\ttaskId: number;\n\tcancel: () => void;\n\tpromise: Promise<void>;\n}\n\ninterface ISequentialTask {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport class TaskSequentializer {\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: ISequentialTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending ? this._pending.promise : undefined;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate rejected = false;\n\tprivate resolved = false;\n\n\tpublic get isRejected() {\n\t\treturn this.rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn this.rejected || this.resolved;\n\t}\n\n\tpublic p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.resolved = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\tnew Promise<void>(resolve => {\n\t\t\tthis.errorCallback(new CancellationError());\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from 'vs/base/common/arrays';\nimport { isThenable } from 'vs/base/common/async';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { LRUCache } from 'vs/base/common/map';\nimport { basename, extname, posix, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { escapeRegExpCharacters } from 'vs/base/common/strings';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\treturn parsedPattern(path.substr(arg2.base.length + 1), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as platform from 'vs/base/common/platform';\nimport * as buffer from 'vs/base/common/buffer';\n\ndeclare const TextDecoder: {\n\tprototype: TextDecoder;\n\tnew(label?: string): TextDecoder;\n};\ninterface TextDecoder {\n\tdecode(view: Uint16Array): string;\n}\n\nexport interface IStringBuilder {\n\tbuild(): string;\n\treset(): void;\n\twrite1(charCode: number): void;\n\tappendASCII(charCode: number): void;\n\tappendASCIIString(str: string): void;\n}\n\nlet _utf16LE_TextDecoder: TextDecoder | null;\nfunction getUTF16LE_TextDecoder(): TextDecoder {\n\tif (!_utf16LE_TextDecoder) {\n\t\t_utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n\t}\n\treturn _utf16LE_TextDecoder;\n}\n\nlet _utf16BE_TextDecoder: TextDecoder | null;\nfunction getUTF16BE_TextDecoder(): TextDecoder {\n\tif (!_utf16BE_TextDecoder) {\n\t\t_utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n\t}\n\treturn _utf16BE_TextDecoder;\n}\n\nlet _platformTextDecoder: TextDecoder | null;\nexport function getPlatformTextDecoder(): TextDecoder {\n\tif (!_platformTextDecoder) {\n\t\t_platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n\t}\n\treturn _platformTextDecoder;\n}\n\nexport const hasTextDecoder = (typeof TextDecoder !== 'undefined');\nexport let createStringBuilder: (capacity: number) => IStringBuilder;\nexport let decodeUTF16LE: (source: Uint8Array, offset: number, len: number) => string;\n\nif (hasTextDecoder) {\n\tcreateStringBuilder = (capacity) => new StringBuilder(capacity);\n\tdecodeUTF16LE = standardDecodeUTF16LE;\n} else {\n\tcreateStringBuilder = (capacity) => new CompatStringBuilder();\n\tdecodeUTF16LE = compatDecodeUTF16LE;\n}\n\nfunction standardDecodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst view = new Uint16Array(source.buffer, offset, len);\n\tif (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n\t\t// UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n\t\t// It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n\t\t// We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n\t\t// So we use the manual decoder\n\t\treturn compatDecodeUTF16LE(source, offset, len);\n\t}\n\treturn getUTF16LE_TextDecoder().decode(view);\n}\n\nfunction compatDecodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst result: string[] = [];\n\tlet resultLen = 0;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst charCode = buffer.readUInt16LE(source, offset); offset += 2;\n\t\tresult[resultLen++] = String.fromCharCode(charCode);\n\t}\n\treturn result.join('');\n}\n\nclass StringBuilder implements IStringBuilder {\n\n\tprivate readonly _capacity: number;\n\tprivate readonly _buffer: Uint16Array;\n\n\tprivate _completedStrings: string[] | null;\n\tprivate _bufferLength: number;\n\n\tconstructor(capacity: number) {\n\t\tthis._capacity = capacity | 0;\n\t\tthis._buffer = new Uint16Array(this._capacity);\n\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic reset(): void {\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic build(): string {\n\t\tif (this._completedStrings !== null) {\n\t\t\tthis._flushBuffer();\n\t\t\treturn this._completedStrings.join('');\n\t\t}\n\t\treturn this._buildBuffer();\n\t}\n\n\tprivate _buildBuffer(): string {\n\t\tif (this._bufferLength === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n\t\treturn getPlatformTextDecoder().decode(view);\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tconst bufferString = this._buildBuffer();\n\t\tthis._bufferLength = 0;\n\n\t\tif (this._completedStrings === null) {\n\t\t\tthis._completedStrings = [bufferString];\n\t\t} else {\n\t\t\tthis._completedStrings[this._completedStrings.length] = bufferString;\n\t\t}\n\t}\n\n\tpublic write1(charCode: number): void {\n\t\tconst remainingSpace = this._capacity - this._bufferLength;\n\n\t\tif (remainingSpace <= 1) {\n\t\t\tif (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n\t\t\t\tthis._flushBuffer();\n\t\t\t}\n\t\t}\n\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\tpublic appendASCII(charCode: number): void {\n\t\tif (this._bufferLength === this._capacity) {\n\t\t\t// buffer is full\n\t\t\tthis._flushBuffer();\n\t\t}\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\tpublic appendASCIIString(str: string): void {\n\t\tconst strLen = str.length;\n\n\t\tif (this._bufferLength + strLen >= this._capacity) {\n\t\t\t// This string does not fit in the remaining buffer space\n\n\t\t\tthis._flushBuffer();\n\t\t\tthis._completedStrings![this._completedStrings!.length] = str;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < strLen; i++) {\n\t\t\tthis._buffer[this._bufferLength++] = str.charCodeAt(i);\n\t\t}\n\t}\n}\n\nclass CompatStringBuilder implements IStringBuilder {\n\n\tprivate _pieces: string[];\n\tprivate _piecesLen: number;\n\n\tconstructor() {\n\t\tthis._pieces = [];\n\t\tthis._piecesLen = 0;\n\t}\n\n\tpublic reset(): void {\n\t\tthis._pieces = [];\n\t\tthis._piecesLen = 0;\n\t}\n\n\tpublic build(): string {\n\t\treturn this._pieces.join('');\n\t}\n\n\tpublic write1(charCode: number): void {\n\t\tthis._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n\t}\n\n\tpublic appendASCII(charCode: number): void {\n\t\tthis._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n\t}\n\n\tpublic appendASCIIString(str: string): void {\n\t\tthis._pieces[this._piecesLen++] = str;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as buffer from 'vs/base/common/buffer';\nimport { decodeUTF16LE } from 'vs/editor/common/core/stringBuilder';\n\nfunction escapeNewLine(str: string): string {\n\treturn (\n\t\tstr\n\t\t\t.replace(/\\n/g, '\\\\n')\n\t\t\t.replace(/\\r/g, '\\\\r')\n\t);\n}\n\nexport class TextChange {\n\n\tpublic get oldLength(): number {\n\t\treturn this.oldText.length;\n\t}\n\n\tpublic get oldEnd(): number {\n\t\treturn this.oldPosition + this.oldText.length;\n\t}\n\n\tpublic get newLength(): number {\n\t\treturn this.newText.length;\n\t}\n\n\tpublic get newEnd(): number {\n\t\treturn this.newPosition + this.newText.length;\n\t}\n\n\tconstructor(\n\t\tpublic readonly oldPosition: number,\n\t\tpublic readonly oldText: string,\n\t\tpublic readonly newPosition: number,\n\t\tpublic readonly newText: string\n\t) { }\n\n\tpublic toString(): string {\n\t\tif (this.oldText.length === 0) {\n\t\t\treturn `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n\t\t}\n\t\tif (this.newText.length === 0) {\n\t\t\treturn `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n\t\t}\n\t\treturn `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n\t}\n\n\tprivate static _writeStringSize(str: string): number {\n\t\treturn (\n\t\t\t4 + 2 * str.length\n\t\t);\n\t}\n\n\tprivate static _writeString(b: Uint8Array, str: string, offset: number): number {\n\t\tconst len = str.length;\n\t\tbuffer.writeUInt32BE(b, len, offset); offset += 4;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tbuffer.writeUInt16LE(b, str.charCodeAt(i), offset); offset += 2;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tprivate static _readString(b: Uint8Array, offset: number): string {\n\t\tconst len = buffer.readUInt32BE(b, offset); offset += 4;\n\t\treturn decodeUTF16LE(b, offset, len);\n\t}\n\n\tpublic writeSize(): number {\n\t\treturn (\n\t\t\t+ 4 // oldPosition\n\t\t\t+ 4 // newPosition\n\t\t\t+ TextChange._writeStringSize(this.oldText)\n\t\t\t+ TextChange._writeStringSize(this.newText)\n\t\t);\n\t}\n\n\tpublic write(b: Uint8Array, offset: number): number {\n\t\tbuffer.writeUInt32BE(b, this.oldPosition, offset); offset += 4;\n\t\tbuffer.writeUInt32BE(b, this.newPosition, offset); offset += 4;\n\t\toffset = TextChange._writeString(b, this.oldText, offset);\n\t\toffset = TextChange._writeString(b, this.newText, offset);\n\t\treturn offset;\n\t}\n\n\tpublic static read(b: Uint8Array, offset: number, dest: TextChange[]): number {\n\t\tconst oldPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst newPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst oldText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(oldText);\n\t\tconst newText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(newText);\n\t\tdest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n\t\treturn offset;\n\t}\n}\n\nexport function compressConsecutiveTextChanges(prevEdits: TextChange[] | null, currEdits: TextChange[]): TextChange[] {\n\tif (prevEdits === null || prevEdits.length === 0) {\n\t\treturn currEdits;\n\t}\n\tconst compressor = new TextChangeCompressor(prevEdits, currEdits);\n\treturn compressor.compress();\n}\n\nclass TextChangeCompressor {\n\n\tprivate _prevEdits: TextChange[];\n\tprivate _currEdits: TextChange[];\n\n\tprivate _result: TextChange[];\n\tprivate _resultLen: number;\n\n\tprivate _prevLen: number;\n\tprivate _prevDeltaOffset: number;\n\n\tprivate _currLen: number;\n\tprivate _currDeltaOffset: number;\n\n\tconstructor(prevEdits: TextChange[], currEdits: TextChange[]) {\n\t\tthis._prevEdits = prevEdits;\n\t\tthis._currEdits = currEdits;\n\n\t\tthis._result = [];\n\t\tthis._resultLen = 0;\n\n\t\tthis._prevLen = this._prevEdits.length;\n\t\tthis._prevDeltaOffset = 0;\n\n\t\tthis._currLen = this._currEdits.length;\n\t\tthis._currDeltaOffset = 0;\n\t}\n\n\tpublic compress(): TextChange[] {\n\t\tlet prevIndex = 0;\n\t\tlet currIndex = 0;\n\n\t\tlet prevEdit = this._getPrev(prevIndex);\n\t\tlet currEdit = this._getCurr(currIndex);\n\n\t\twhile (prevIndex < this._prevLen || currIndex < this._currLen) {\n\n\t\t\tif (prevEdit === null) {\n\t\t\t\tthis._acceptCurr(currEdit!);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit === null) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldEnd <= prevEdit.newPosition) {\n\t\t\t\tthis._acceptCurr(currEdit);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newEnd <= currEdit.oldPosition) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldPosition < prevEdit.newPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n\t\t\t\tthis._acceptCurr(e1);\n\t\t\t\tcurrEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newPosition < currEdit.oldPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n\t\t\t\tthis._acceptPrev(e1);\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point, currEdit.oldPosition === prevEdit.newPosition\n\n\t\t\tlet mergePrev: TextChange;\n\t\t\tlet mergeCurr: TextChange;\n\n\t\t\tif (currEdit.oldEnd === prevEdit.newEnd) {\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else if (currEdit.oldEnd < prevEdit.newEnd) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n\t\t\t\tmergePrev = e1;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = e1;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = e2;\n\t\t\t}\n\n\t\t\tthis._result[this._resultLen++] = new TextChange(\n\t\t\t\tmergePrev.oldPosition,\n\t\t\t\tmergePrev.oldText,\n\t\t\t\tmergeCurr.newPosition,\n\t\t\t\tmergeCurr.newText\n\t\t\t);\n\t\t\tthis._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n\t\t\tthis._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n\t\t}\n\n\t\tconst merged = TextChangeCompressor._merge(this._result);\n\t\tconst cleaned = TextChangeCompressor._removeNoOps(merged);\n\t\treturn cleaned;\n\t}\n\n\tprivate _acceptCurr(currEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n\t\tthis._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n\t}\n\n\tprivate _getCurr(currIndex: number): TextChange | null {\n\t\treturn (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n\t}\n\n\tprivate _acceptPrev(prevEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n\t\tthis._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n\t}\n\n\tprivate _getPrev(prevIndex: number): TextChange | null {\n\t\treturn (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n\t}\n\n\tprivate static _rebaseCurr(prevDeltaOffset: number, currEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tcurrEdit.oldPosition - prevDeltaOffset,\n\t\t\tcurrEdit.oldText,\n\t\t\tcurrEdit.newPosition,\n\t\t\tcurrEdit.newText\n\t\t);\n\t}\n\n\tprivate static _rebasePrev(currDeltaOffset: number, prevEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tprevEdit.oldPosition,\n\t\t\tprevEdit.oldText,\n\t\t\tprevEdit.newPosition + currDeltaOffset,\n\t\t\tprevEdit.newText\n\t\t);\n\t}\n\n\tprivate static _splitPrev(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.newText.substr(0, offset);\n\t\tconst postText = edit.newText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tedit.oldText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tpreText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldEnd,\n\t\t\t\t'',\n\t\t\t\tedit.newPosition + offset,\n\t\t\t\tpostText\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _splitCurr(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.oldText.substr(0, offset);\n\t\tconst postText = edit.oldText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tpreText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tedit.newText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition + offset,\n\t\t\t\tpostText,\n\t\t\t\tedit.newEnd,\n\t\t\t\t''\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _merge(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tlet prev = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tconst curr = edits[i];\n\n\t\t\tif (prev.oldEnd === curr.oldPosition) {\n\t\t\t\t// Merge into `prev`\n\t\t\t\tprev = new TextChange(\n\t\t\t\t\tprev.oldPosition,\n\t\t\t\t\tprev.oldText + curr.oldText,\n\t\t\t\t\tprev.newPosition,\n\t\t\t\t\tprev.newText + curr.newText\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = prev;\n\t\t\t\tprev = curr;\n\t\t\t}\n\t\t}\n\t\tresult[resultLen++] = prev;\n\n\t\treturn result;\n\t}\n\n\tprivate static _removeNoOps(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\n\t\t\tif (edit.oldText === edit.newText) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[resultLen++] = edit;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { FindMatch, ITextSnapshot, SearchData } from 'vs/editor/common/model';\nimport { NodeColor, SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from 'vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase';\nimport { Searcher, createFindMatch, isValidMatch } from 'vs/editor/common/model/textModelSearch';\n\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport const AverageBufferSize = 65535;\n\nexport function createUintArray(arr: number[]): Uint32Array | Uint16Array {\n\tlet r;\n\tif (arr[arr.length - 1] < 65536) {\n\t\tr = new Uint16Array(arr.length);\n\t} else {\n\t\tr = new Uint32Array(arr.length);\n\t}\n\tr.set(arr, 0);\n\treturn r;\n}\n\nexport class LineStarts {\n\tconstructor(\n\t\tpublic readonly lineStarts: Uint32Array | Uint16Array | number[],\n\t\tpublic readonly cr: number,\n\t\tpublic readonly lf: number,\n\t\tpublic readonly crlf: number,\n\t\tpublic readonly isBasicASCII: boolean\n\t) { }\n}\n\nexport function createLineStartsFast(str: string, readonly: boolean = true): Uint32Array | Uint16Array | number[] {\n\tconst r: number[] = [0];\n\tlet rLength = 1;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tr[rLength++] = i + 1;\n\t\t}\n\t}\n\tif (readonly) {\n\t\treturn createUintArray(r);\n\t} else {\n\t\treturn r;\n\t}\n}\n\nexport function createLineStarts(r: number[], str: string): LineStarts {\n\tr.length = 0;\n\tr[0] = 0;\n\tlet rLength = 1;\n\tlet cr = 0, lf = 0, crlf = 0;\n\tlet isBasicASCII = true;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tcrlf++;\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\tcr++;\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tlf++;\n\t\t\tr[rLength++] = i + 1;\n\t\t} else {\n\t\t\tif (isBasicASCII) {\n\t\t\t\tif (chr !== CharCode.Tab && (chr < 32 || chr > 126)) {\n\t\t\t\t\tisBasicASCII = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n\tr.length = 0;\n\n\treturn result;\n}\n\nexport interface NodePosition {\n\t/**\n\t * Piece Index\n\t */\n\tnode: TreeNode;\n\t/**\n\t * remainer in current piece.\n\t*/\n\tremainder: number;\n\t/**\n\t * node start offset in document.\n\t */\n\tnodeStartOffset: number;\n}\n\nexport interface BufferCursor {\n\t/**\n\t * Line number in current buffer\n\t */\n\tline: number;\n\t/**\n\t * Column number in current buffer\n\t */\n\tcolumn: number;\n}\n\nexport class Piece {\n\treadonly bufferIndex: number;\n\treadonly start: BufferCursor;\n\treadonly end: BufferCursor;\n\treadonly length: number;\n\treadonly lineFeedCnt: number;\n\n\tconstructor(bufferIndex: number, start: BufferCursor, end: BufferCursor, lineFeedCnt: number, length: number) {\n\t\tthis.bufferIndex = bufferIndex;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.lineFeedCnt = lineFeedCnt;\n\t\tthis.length = length;\n\t}\n}\n\nexport class StringBuffer {\n\tbuffer: string;\n\tlineStarts: Uint32Array | Uint16Array | number[];\n\n\tconstructor(buffer: string, lineStarts: Uint32Array | Uint16Array | number[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.lineStarts = lineStarts;\n\t}\n}\n\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot implements ITextSnapshot {\n\tprivate readonly _pieces: Piece[];\n\tprivate _index: number;\n\tprivate readonly _tree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\n\tconstructor(tree: PieceTreeBase, BOM: string) {\n\t\tthis._pieces = [];\n\t\tthis._tree = tree;\n\t\tthis._BOM = BOM;\n\t\tthis._index = 0;\n\t\tif (tree.root !== SENTINEL) {\n\t\t\ttree.iterate(tree.root, node => {\n\t\t\t\tif (node !== SENTINEL) {\n\t\t\t\t\tthis._pieces.push(node.piece);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\tread(): string | null {\n\t\tif (this._pieces.length === 0) {\n\t\t\tif (this._index === 0) {\n\t\t\t\tthis._index++;\n\t\t\t\treturn this._BOM;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._index > this._pieces.length - 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._index === 0) {\n\t\t\treturn this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n\t\t}\n\t\treturn this._tree.getPieceContent(this._pieces[this._index++]);\n\t}\n}\n\ninterface CacheEntry {\n\tnode: TreeNode;\n\tnodeStartOffset: number;\n\tnodeStartLineNumber?: number;\n}\n\nclass PieceTreeSearchCache {\n\tprivate readonly _limit: number;\n\tprivate _cache: CacheEntry[];\n\n\tconstructor(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis._cache = [];\n\t}\n\n\tpublic get(offset: number): CacheEntry | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n\t\t\t\treturn nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic get2(lineNumber: number): { node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number } | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n\t\t\t\treturn <{ node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number }>nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic set(nodePosition: CacheEntry) {\n\t\tif (this._cache.length >= this._limit) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t\tthis._cache.push(nodePosition);\n\t}\n\n\tpublic validate(offset: number) {\n\t\tlet hasInvalidVal = false;\n\t\tconst tmp: Array<CacheEntry | null> = this._cache;\n\t\tfor (let i = 0; i < tmp.length; i++) {\n\t\t\tconst nodePos = tmp[i]!;\n\t\t\tif (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n\t\t\t\ttmp[i] = null;\n\t\t\t\thasInvalidVal = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInvalidVal) {\n\t\t\tconst newArr: CacheEntry[] = [];\n\t\t\tfor (const entry of tmp) {\n\t\t\t\tif (entry !== null) {\n\t\t\t\t\tnewArr.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._cache = newArr;\n\t\t}\n\t}\n}\n\nexport class PieceTreeBase {\n\troot!: TreeNode;\n\tprotected _buffers!: StringBuffer[]; // 0 is change buffer, others are readonly original buffer.\n\tprotected _lineCnt!: number;\n\tprotected _length!: number;\n\tprotected _EOL!: '\\r\\n' | '\\n';\n\tprotected _EOLLength!: number;\n\tprotected _EOLNormalized!: boolean;\n\tprivate _lastChangeBufferPos!: BufferCursor;\n\tprivate _searchCache!: PieceTreeSearchCache;\n\tprivate _lastVisitedLine!: { lineNumber: number; value: string };\n\n\tconstructor(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis.create(chunks, eol, eolNormalized);\n\t}\n\n\tcreate(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis._buffers = [\n\t\t\tnew StringBuffer('', [0])\n\t\t];\n\t\tthis._lastChangeBufferPos = { line: 0, column: 0 };\n\t\tthis.root = SENTINEL;\n\t\tthis._lineCnt = 1;\n\t\tthis._length = 0;\n\t\tthis._EOL = eol;\n\t\tthis._EOLLength = eol.length;\n\t\tthis._EOLNormalized = eolNormalized;\n\n\t\tlet lastNode: TreeNode | null = null;\n\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\tif (chunks[i].buffer.length > 0) {\n\t\t\t\tif (!chunks[i].lineStarts) {\n\t\t\t\t\tchunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n\t\t\t\t}\n\n\t\t\t\tconst piece = new Piece(\n\t\t\t\t\ti + 1,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] },\n\t\t\t\t\tchunks[i].lineStarts.length - 1,\n\t\t\t\t\tchunks[i].buffer.length\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(chunks[i]);\n\t\t\t\tlastNode = this.rbInsertRight(lastNode, piece);\n\t\t\t}\n\t\t}\n\n\t\tthis._searchCache = new PieceTreeSearchCache(1);\n\t\tthis._lastVisitedLine = { lineNumber: 0, value: '' };\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n') {\n\t\tconst averageBufferSize = AverageBufferSize;\n\t\tconst min = averageBufferSize - Math.floor(averageBufferSize / 3);\n\t\tconst max = min * 2;\n\n\t\tlet tempChunk = '';\n\t\tlet tempChunkLen = 0;\n\t\tconst chunks: StringBuffer[] = [];\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tif (tempChunkLen <= min || tempChunkLen + len < max) {\n\t\t\t\ttempChunk += str;\n\t\t\t\ttempChunkLen += len;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// flush anyways\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t\ttempChunk = str;\n\t\t\ttempChunkLen = len;\n\t\t\treturn true;\n\t\t});\n\n\t\tif (tempChunkLen > 0) {\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t}\n\n\t\tthis.create(chunks, eol, true);\n\t}\n\n\t// #region Buffer API\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._EOL;\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._EOL = newEOL;\n\t\tthis._EOLLength = this._EOL.length;\n\t\tthis.normalizeEOL(newEOL);\n\t}\n\n\tpublic createSnapshot(BOM: string): ITextSnapshot {\n\t\treturn new PieceTreeSnapshot(this, BOM);\n\t}\n\n\tpublic equal(other: PieceTreeBase): boolean {\n\t\tif (this.getLength() !== other.getLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getLineCount() !== other.getLineCount()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst offset = 0;\n\t\tconst ret = this.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tconst startPosition = other.nodeAt(offset);\n\t\t\tconst endPosition = other.nodeAt(offset + len);\n\t\t\tconst val = other.getValueInRange2(startPosition, endPosition);\n\n\t\t\treturn str === val;\n\t\t});\n\n\t\treturn ret;\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\tlet leftLen = 0; // inorder\n\n\t\tlet x = this.root;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n\t\t\t\tleftLen += x.size_left;\n\t\t\t\t// lineNumber >= 2\n\t\t\t\tconst accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\treturn leftLen += accumualtedValInCurrentIndex + column - 1;\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tleftLen += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn leftLen;\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tlet x = this.root;\n\t\tlet lfCnt = 0;\n\t\tconst originalOffset = offset;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left !== 0 && x.size_left >= offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tconst out = this.getIndexOf(x, offset - x.size_left);\n\n\t\t\t\tlfCnt += x.lf_left + out.index;\n\n\t\t\t\tif (out.index === 0) {\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t}\n\n\t\t\t\treturn new Position(lfCnt + 1, out.remainder + 1);\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n\t\t\t\tif (x.right === SENTINEL) {\n\t\t\t\t\t// last node\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - offset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t} else {\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(1, 1);\n\t}\n\n\tpublic getValueInRange(range: Range, eol?: string): string {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n\t\tconst endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n\n\t\tconst value = this.getValueInRange2(startPosition, endPosition);\n\t\tif (eol) {\n\t\t\tif (eol !== this._EOL || !this._EOLNormalized) {\n\t\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t}\n\n\t\t\tif (eol === this.getEOL() && this._EOLNormalized) {\n\t\t\t\tif (eol === '\\r\\n') {\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic getValueInRange2(startPosition: NodePosition, endPosition: NodePosition): string {\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tconst node = startPosition.node;\n\t\t\tconst buffer = this._buffers[node.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\t\treturn buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n\t\t}\n\n\t\tlet x = startPosition.node;\n\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\tlet ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\tif (x === endPosition.node) {\n\t\t\t\tret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tconst lines: string[] = [];\n\t\tlet linesLength = 0;\n\t\tlet currentLine = '';\n\t\tlet danglingCR = false;\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst piece = node.piece;\n\t\t\tlet pieceLength = piece.length;\n\t\t\tif (pieceLength === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[piece.bufferIndex].buffer;\n\t\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\n\t\t\tconst pieceStartLine = piece.start.line;\n\t\t\tconst pieceEndLine = piece.end.line;\n\t\t\tlet pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n\t\t\tif (danglingCR) {\n\t\t\t\tif (buffer.charCodeAt(pieceStartOffset) === CharCode.LineFeed) {\n\t\t\t\t\t// pretend the \\n was in the previous piece..\n\t\t\t\t\tpieceStartOffset++;\n\t\t\t\t\tpieceLength--;\n\t\t\t\t}\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t\tcurrentLine = '';\n\t\t\t\tdanglingCR = false;\n\t\t\t\tif (pieceLength === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pieceStartLine === pieceEndLine) {\n\t\t\t\t// this piece has no new lines\n\t\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === CharCode.CarriageReturn) {\n\t\t\t\t\tdanglingCR = true;\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// add the text before the first line start in this piece\n\t\t\tcurrentLine += (\n\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n\t\t\t\t\t: buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t);\n\t\t\tlines[linesLength++] = currentLine;\n\n\t\t\tfor (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n\t\t\t\tcurrentLine = (\n\t\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t\t? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n\t\t\t\t\t\t: buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t\t);\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t}\n\n\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === CharCode.CarriageReturn) {\n\t\t\t\tdanglingCR = true;\n\t\t\t\tif (piece.end.column === 0) {\n\t\t\t\t\t// The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n\t\t\t\t\tlinesLength--;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (danglingCR) {\n\t\t\tlines[linesLength++] = currentLine;\n\t\t\tcurrentLine = '';\n\t\t}\n\n\t\tlines[linesLength++] = currentLine;\n\t\treturn lines;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._length;\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lineCnt;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._lastVisitedLine.lineNumber === lineNumber) {\n\t\t\treturn this._lastVisitedLine.value;\n\t\t}\n\n\t\tthis._lastVisitedLine.lineNumber = lineNumber;\n\n\t\tif (lineNumber === this._lineCnt) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n\t\t} else if (this._EOLNormalized) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n\t\t} else {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n\t\t}\n\n\t\treturn this._lastVisitedLine.value;\n\t}\n\n\tprivate _getCharCode(nodePos: NodePosition): number {\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the char we want to fetch is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.charCodeAt(startOffset);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\n\t\t\treturn buffer.buffer.charCodeAt(targetOffset);\n\t\t}\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\tconst nodePos = this.nodeAt2(lineNumber, index + 1);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tif (lineNumber === this.getLineCount()) {\n\t\t\tconst startOffset = this.getOffsetAt(lineNumber, 1);\n\t\t\treturn this.getLength() - startOffset;\n\t\t}\n\t\treturn this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic findMatchesInNode(node: TreeNode, searcher: Searcher, startLineNumber: number, startColumn: number, startCursor: BufferCursor, endCursor: BufferCursor, searchData: SearchData, captureMatches: boolean, limitResultCount: number, resultLen: number, result: FindMatch[]) {\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\tconst start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n\t\tconst end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tconst ret: BufferCursor = { line: 0, column: 0 };\n\t\tlet searchText: string;\n\t\tlet offsetInBuffer: (offset: number) => number;\n\n\t\tif (searcher._wordSeparators) {\n\t\t\tsearchText = buffer.buffer.substring(start, end);\n\t\t\toffsetInBuffer = (offset: number) => offset + start;\n\t\t\tsearcher.reset(0);\n\t\t} else {\n\t\t\tsearchText = buffer.buffer;\n\t\t\toffsetInBuffer = (offset: number) => offset;\n\t\t\tsearcher.reset(start);\n\t\t}\n\n\t\tdo {\n\t\t\tm = searcher.next(searchText);\n\n\t\t\tif (m) {\n\t\t\t\tif (offsetInBuffer(m.index) >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tthis.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n\t\t\t\tconst lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n\t\t\t\tconst retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n\t\t\t\tconst retEndColumn = retStartColumn + m[0].length;\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n\t\t\t\tif (offsetInBuffer(m.index) + m[0].length >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn resultLen;\n\t}\n\n\tpublic findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tlet startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\t\tif (startPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\t\tif (endPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\tconst end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tthis.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startLineNumber = searchRange.startLineNumber;\n\n\t\tlet currentNode = startPosition.node;\n\t\twhile (currentNode !== endPosition.node) {\n\t\t\tconst lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n\t\t\tif (lineBreakCnt >= 1) {\n\t\t\t\t// last line break position\n\t\t\t\tconst lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n\t\t\t\tconst startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n\t\t\t\tconst nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n\t\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\t\t\tresultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber += lineBreakCnt;\n\t\t\t}\n\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\t// search for the remaining content\n\t\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\n\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tstartLineNumber++;\n\t\t\tstartPosition = this.nodeAt2(startLineNumber, 1);\n\t\t\tcurrentNode = startPosition.node;\n\t\t\tstart = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\t}\n\n\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\tresultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\treturn result;\n\t}\n\n\tprivate _findMatchesInLine(searchData: SearchData, searcher: Searcher, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\t// #endregion\n\n\t// #region Piece Table\n\tpublic insert(offset: number, value: string, eolNormalized: boolean = false): void {\n\t\tthis._EOLNormalized = this._EOLNormalized && eolNormalized;\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (this.root !== SENTINEL) {\n\t\t\tconst { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n\t\t\tconst piece = node.piece;\n\t\t\tconst bufferIndex = piece.bufferIndex;\n\t\t\tconst insertPosInBuffer = this.positionInBuffer(node, remainder);\n\t\t\tif (node.piece.bufferIndex === 0 &&\n\t\t\t\tpiece.end.line === this._lastChangeBufferPos.line &&\n\t\t\t\tpiece.end.column === this._lastChangeBufferPos.column &&\n\t\t\t\t(nodeStartOffset + piece.length === offset) &&\n\t\t\t\tvalue.length < AverageBufferSize\n\t\t\t) {\n\t\t\t\t// changed buffer\n\t\t\t\tthis.appendToNode(node, value);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nodeStartOffset === offset) {\n\t\t\t\tthis.insertContentToNodeLeft(value, node);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t} else if (nodeStartOffset + node.piece.length > offset) {\n\t\t\t\t// we are inserting into the middle of a node.\n\t\t\t\tconst nodesToDel: TreeNode[] = [];\n\t\t\t\tlet newRightPiece = new Piece(\n\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\tpiece.end,\n\t\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),\n\t\t\t\t\tthis.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)\n\t\t\t\t);\n\n\t\t\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\t\t\tconst headOfRight = this.nodeCharCodeAt(node, remainder);\n\n\t\t\t\t\tif (headOfRight === 10 /** \\n */) {\n\t\t\t\t\t\tconst newStart: BufferCursor = { line: newRightPiece.start.line + 1, column: 0 };\n\t\t\t\t\t\tnewRightPiece = new Piece(\n\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\tthis.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),\n\t\t\t\t\t\t\tnewRightPiece.length - 1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvalue += '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reuse node for content before insertion point.\n\t\t\t\tif (this.shouldCheckCRLF() && this.startWithLF(value)) {\n\t\t\t\t\tconst tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\t\t\t\t\tif (tailOfLeft === 13 /** \\r */) {\n\t\t\t\t\t\tconst previousPos = this.positionInBuffer(node, remainder - 1);\n\t\t\t\t\t\tthis.deleteNodeTail(node, previousPos);\n\t\t\t\t\t\tvalue = '\\r' + value;\n\n\t\t\t\t\t\tif (node.piece.length === 0) {\n\t\t\t\t\t\t\tnodesToDel.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t}\n\n\t\t\t\tconst newPieces = this.createNewPieces(value);\n\t\t\t\tif (newRightPiece.length > 0) {\n\t\t\t\t\tthis.rbInsertRight(node, newRightPiece);\n\t\t\t\t}\n\n\t\t\t\tlet tmpNode = node;\n\t\t\t\tfor (let k = 0; k < newPieces.length; k++) {\n\t\t\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t\t\t}\n\t\t\t\tthis.deleteNodes(nodesToDel);\n\t\t\t} else {\n\t\t\t\tthis.insertContentToNodeRight(value, node);\n\t\t\t}\n\t\t} else {\n\t\t\t// insert new node\n\t\t\tconst pieces = this.createNewPieces(value);\n\t\t\tlet node = this.rbInsertLeft(null, pieces[0]);\n\n\t\t\tfor (let k = 1; k < pieces.length; k++) {\n\t\t\t\tnode = this.rbInsertRight(node, pieces[k]);\n\t\t\t}\n\t\t}\n\n\t\t// todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tpublic delete(offset: number, cnt: number): void {\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (cnt <= 0 || this.root === SENTINEL) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startPosition = this.nodeAt(offset);\n\t\tconst endPosition = this.nodeAt(offset + cnt);\n\t\tconst startNode = startPosition.node;\n\t\tconst endNode = endPosition.node;\n\n\t\tif (startNode === endNode) {\n\t\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\t\tconst endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n\t\t\tif (startPosition.nodeStartOffset === offset) {\n\t\t\t\tif (cnt === startNode.piece.length) { // delete node\n\t\t\t\t\tconst next = startNode.next();\n\t\t\t\t\trbDelete(this, startNode);\n\t\t\t\t\tthis.validateCRLFWithPrevNode(next);\n\t\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.deleteNodeHead(startNode, endSplitPosInBuffer);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t\tthis.validateCRLFWithPrevNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n\t\t\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\t\t\tthis.validateCRLFWithNextNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// delete content in the middle, this node will be splitted to nodes\n\t\t\tthis.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n\t\t\tthis.computeBufferMetadata();\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodesToDel: TreeNode[] = [];\n\n\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\tthis._searchCache.validate(offset);\n\t\tif (startNode.piece.length === 0) {\n\t\t\tnodesToDel.push(startNode);\n\t\t}\n\n\t\t// update last touched node\n\t\tconst endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n\t\tthis.deleteNodeHead(endNode, endSplitPosInBuffer);\n\t\tif (endNode.piece.length === 0) {\n\t\t\tnodesToDel.push(endNode);\n\t\t}\n\n\t\t// delete nodes in between\n\t\tconst secondNode = startNode.next();\n\t\tfor (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n\t\t\tnodesToDel.push(node);\n\t\t}\n\n\t\tconst prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n\t\tthis.deleteNodes(nodesToDel);\n\t\tthis.validateCRLFWithNextNode(prev);\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tprivate insertContentToNodeLeft(value: string, node: TreeNode) {\n\t\t// we are inserting content to the beginning of node\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n\t\t\t// move `\\n` to new node.\n\n\t\t\tconst piece = node.piece;\n\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\tconst nPiece = new Piece(\n\t\t\t\tpiece.bufferIndex,\n\t\t\t\tnewStart,\n\t\t\t\tpiece.end,\n\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n\t\t\t\tpiece.length - 1\n\t\t\t);\n\n\t\t\tnode.piece = nPiece;\n\n\t\t\tvalue += '\\n';\n\t\t\tupdateTreeMetadata(this, node, -1, -1);\n\n\t\t\tif (node.piece.length === 0) {\n\t\t\t\tnodesToDel.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\t\tfor (let k = newPieces.length - 2; k >= 0; k--) {\n\t\t\tnewNode = this.rbInsertLeft(newNode, newPieces[k]);\n\t\t}\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t\tthis.deleteNodes(nodesToDel);\n\t}\n\n\tprivate insertContentToNodeRight(value: string, node: TreeNode) {\n\t\t// we are inserting to the right of this node.\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\t// move \\n to the new node.\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tconst newNode = this.rbInsertRight(node, newPieces[0]);\n\t\tlet tmpNode = newNode;\n\n\t\tfor (let k = 1; k < newPieces.length; k++) {\n\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t}\n\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate positionInBuffer(node: TreeNode, remainder: number): BufferCursor;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret: BufferCursor): null;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret?: BufferCursor): BufferCursor | null {\n\t\tconst piece = node.piece;\n\t\tconst bufferIndex = node.piece.bufferIndex;\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\n\t\tconst startOffset = lineStarts[piece.start.line] + piece.start.column;\n\n\t\tconst offset = startOffset + remainder;\n\n\t\t// binary search offset between startOffset and endOffset\n\t\tlet low = piece.start.line;\n\t\tlet high = piece.end.line;\n\n\t\tlet mid: number = 0;\n\t\tlet midStop: number = 0;\n\t\tlet midStart: number = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\t\t\tmidStart = lineStarts[mid];\n\n\t\t\tif (mid === high) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmidStop = lineStarts[mid + 1];\n\n\t\t\tif (offset < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offset >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret.line = mid;\n\t\t\tret.column = offset - midStart;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tline: mid,\n\t\t\tcolumn: offset - midStart\n\t\t};\n\t}\n\n\tprivate getLineFeedCnt(bufferIndex: number, start: BufferCursor, end: BufferCursor): number {\n\t\t// we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n\t\t// now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n\t\tif (end.column === 0) {\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\tif (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst nextLineStartOffset = lineStarts[end.line + 1];\n\t\tconst endOffset = lineStarts[end.line] + end.column;\n\t\tif (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n\t\t\treturn end.line - start.line;\n\t\t}\n\t\t// endOffset + 1 === nextLineStartOffset\n\t\t// character at endOffset is \\n, so we check the character before first\n\t\t// if character at endOffset is \\r, end.column is 0 and we can't get here.\n\t\tconst previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\t\tconst buffer = this._buffers[bufferIndex].buffer;\n\n\t\tif (buffer.charCodeAt(previousCharOffset) === 13) {\n\t\t\treturn end.line - start.line + 1;\n\t\t} else {\n\t\t\treturn end.line - start.line;\n\t\t}\n\t}\n\n\tprivate offsetInBuffer(bufferIndex: number, cursor: BufferCursor): number {\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\treturn lineStarts[cursor.line] + cursor.column;\n\t}\n\n\tprivate deleteNodes(nodes: TreeNode[]): void {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\trbDelete(this, nodes[i]);\n\t\t}\n\t}\n\n\tprivate createNewPieces(text: string): Piece[] {\n\t\tif (text.length > AverageBufferSize) {\n\t\t\t// the content is large, operations like substring, charCode becomes slow\n\t\t\t// so here we split it into smaller chunks, just like what we did for CR/LF normalization\n\t\t\tconst newPieces: Piece[] = [];\n\t\t\twhile (text.length > AverageBufferSize) {\n\t\t\t\tconst lastChar = text.charCodeAt(AverageBufferSize - 1);\n\t\t\t\tlet splitText;\n\t\t\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize - 1);\n\t\t\t\t\ttext = text.substring(AverageBufferSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize);\n\t\t\t\t\ttext = text.substring(AverageBufferSize);\n\t\t\t\t}\n\n\t\t\t\tconst lineStarts = createLineStartsFast(splitText);\n\t\t\t\tnewPieces.push(new Piece(\n\t\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\tsplitText.length\n\t\t\t\t));\n\t\t\t\tthis._buffers.push(new StringBuffer(splitText, lineStarts));\n\t\t\t}\n\n\t\t\tconst lineStarts = createLineStartsFast(text);\n\t\t\tnewPieces.push(new Piece(\n\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t{ line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\tlineStarts.length - 1,\n\t\t\t\ttext.length\n\t\t\t));\n\t\t\tthis._buffers.push(new StringBuffer(text, lineStarts));\n\n\t\t\treturn newPieces;\n\t\t}\n\n\t\tlet startOffset = this._buffers[0].buffer.length;\n\t\tconst lineStarts = createLineStartsFast(text, false);\n\n\t\tlet start = this._lastChangeBufferPos;\n\t\tif (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n\t\t\t&& startOffset !== 0\n\t\t\t&& this.startWithLF(text)\n\t\t\t&& this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n\t\t) {\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n\t\t\tstart = this._lastChangeBufferPos;\n\n\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\tlineStarts[i] += startOffset + 1;\n\t\t\t}\n\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += '_' + text;\n\t\t\tstartOffset += 1;\n\t\t} else {\n\t\t\tif (startOffset !== 0) {\n\t\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\t\tlineStarts[i] += startOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += text;\n\t\t}\n\n\t\tconst endOffset = this._buffers[0].buffer.length;\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n\t\tconst endPos = { line: endIndex, column: endColumn };\n\t\tconst newPiece = new Piece(\n\t\t\t0, /** todo@peng */\n\t\t\tstart,\n\t\t\tendPos,\n\t\t\tthis.getLineFeedCnt(0, start, endPos),\n\t\t\tendOffset - startOffset\n\t\t);\n\t\tthis._lastChangeBufferPos = endPos;\n\t\treturn [newPiece];\n\t}\n\n\tpublic getLinesRawContent(): string {\n\t\treturn this.getContentOfSubTree(this.root);\n\t}\n\n\tpublic getLineRawContent(lineNumber: number, endOffset: number = 0): string {\n\t\tlet x = this.root;\n\n\t\tlet ret = '';\n\t\tconst cache = this._searchCache.get2(lineNumber);\n\t\tif (cache) {\n\t\t\tx = cache.node;\n\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\tif (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t} else {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tlet nodeStartOffset = 0;\n\t\t\tconst originalLineNumber = lineNumber;\n\t\t\twhile (x !== SENTINEL) {\n\t\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\t\tx = x.left;\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\t\tthis._searchCache.set({\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t\tnodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n\t\t\t\t\t});\n\n\t\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains end column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\tret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate computeBufferMetadata() {\n\t\tlet x = this.root;\n\n\t\tlet lfCnt = 1;\n\t\tlet len = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\t\t\tlen += x.size_left + x.piece.length;\n\t\t\tx = x.right;\n\t\t}\n\n\t\tthis._lineCnt = lfCnt;\n\t\tthis._length = len;\n\t\tthis._searchCache.validate(this._length);\n\t}\n\n\t// #region node operations\n\tprivate getIndexOf(node: TreeNode, accumulatedValue: number): { index: number; remainder: number } {\n\t\tconst piece = node.piece;\n\t\tconst pos = this.positionInBuffer(node, accumulatedValue);\n\t\tconst lineCnt = pos.line - piece.start.line;\n\n\t\tif (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n\t\t\t// we are checking the end of this node, so a CRLF check is necessary.\n\t\t\tconst realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\t\t\tif (realLineCnt !== lineCnt) {\n\t\t\t\t// aha yes, CRLF\n\t\t\t\treturn { index: realLineCnt, remainder: 0 };\n\t\t\t}\n\t\t}\n\n\t\treturn { index: lineCnt, remainder: pos.column };\n\t}\n\n\tprivate getAccumulatedValue(node: TreeNode, index: number) {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst piece = node.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst expectedLineStartIndex = piece.start.line + index + 1;\n\t\tif (expectedLineStartIndex > piece.end.line) {\n\t\t\treturn lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n\t\t} else {\n\t\t\treturn lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n\t\t}\n\t}\n\n\tprivate deleteNodeTail(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\n\t\tconst newEnd = pos;\n\t\tconst newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = newEndOffset - originalEndOffset;\n\t\tconst newLength = piece.length + size_delta;\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate deleteNodeHead(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\n\t\tconst newStart = pos;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\tconst newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = originalStartOffset - newStartOffset;\n\t\tconst newLength = piece.length + size_delta;\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate shrinkNode(node: TreeNode, start: BufferCursor, end: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalStartPos = piece.start;\n\t\tconst originalEndPos = piece.end;\n\n\t\t// old piece, originalStartPos, start\n\t\tconst oldLength = piece.length;\n\t\tconst oldLFCnt = piece.lineFeedCnt;\n\t\tconst newEnd = start;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\t\tconst newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n\n\t\t// new right piece, end, originalEndPos\n\t\tconst newPiece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tend,\n\t\t\toriginalEndPos,\n\t\t\tthis.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)\n\t\t);\n\n\t\tconst newNode = this.rbInsertRight(node, newPiece);\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate appendToNode(node: TreeNode, value: string): void {\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n\t\tconst startOffset = this._buffers[0].buffer.length;\n\t\tthis._buffers[0].buffer += value;\n\t\tconst lineStarts = createLineStartsFast(value, false);\n\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\tlineStarts[i] += startOffset;\n\t\t}\n\t\tif (hitCRLF) {\n\t\t\tconst prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\t\t\t(<number[]>this._buffers[0].lineStarts).pop();\n\t\t\t// _lastChangeBufferPos is already wrong\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n\t\t}\n\n\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n\t\tconst newEnd = { line: endIndex, column: endColumn };\n\t\tconst newLength = node.piece.length + value.length;\n\t\tconst oldLineFeedCnt = node.piece.lineFeedCnt;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n\t\tconst lf_delta = newLineFeedCnt - oldLineFeedCnt;\n\n\t\tnode.piece = new Piece(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tthis._lastChangeBufferPos = newEnd;\n\t\tupdateTreeMetadata(this, node, value.length, lf_delta);\n\t}\n\n\tprivate nodeAt(offset: number): NodePosition {\n\t\tlet x = this.root;\n\t\tconst cache = this._searchCache.get(offset);\n\t\tif (cache) {\n\t\t\treturn {\n\t\t\t\tnode: cache.node,\n\t\t\t\tnodeStartOffset: cache.nodeStartOffset,\n\t\t\t\tremainder: offset - cache.nodeStartOffset\n\t\t\t};\n\t\t}\n\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left > offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\tconst ret = {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: offset - x.size_left,\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t\tthis._searchCache.set(ret);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeAt2(lineNumber: number, column: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\tnodeStartOffset += x.size_left;\n\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tif (prevAccumualtedValue + column - 1 <= x.piece.length) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: prevAccumualtedValue + column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length - prevAccumualtedValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains position.column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (x.piece.length >= column - 1) {\n\t\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeCharCodeAt(node: TreeNode, offset: number): number {\n\t\tif (node.piece.lineFeedCnt < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n\t\treturn buffer.buffer.charCodeAt(newOffset);\n\t}\n\n\tprivate offsetOfNode(node: TreeNode): number {\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet pos = node.size_left;\n\t\twhile (node !== this.root) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tpos += node.parent.size_left + node.parent.piece.length;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// #endregion\n\n\t// #region CRLF\n\tprivate shouldCheckCRLF() {\n\t\treturn !(this._EOLNormalized && this._EOL === '\\n');\n\t}\n\n\tprivate startWithLF(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(0) === 10;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst piece = val.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst line = piece.start.line;\n\t\tconst startOffset = lineStarts[line] + piece.start.column;\n\t\tif (line === lineStarts.length - 1) {\n\t\t\t// last line, so there is no line feed at the end of this line\n\t\t\treturn false;\n\t\t}\n\t\tconst nextLineOffset = lineStarts[line + 1];\n\t\tif (nextLineOffset > startOffset + 1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n\t}\n\n\tprivate endWithCR(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(val.length - 1) === 13;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n\t}\n\n\tprivate validateCRLFWithPrevNode(nextNode: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n\t\t\tconst node = nextNode.prev();\n\t\t\tif (this.endWithCR(node)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate validateCRLFWithNextNode(node: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(node)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fixCRLF(prev: TreeNode, next: TreeNode) {\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\t// update node\n\t\tconst lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n\t\tlet newEnd: BufferCursor;\n\t\tif (prev.piece.end.column === 0) {\n\t\t\t// it means, last line ends with \\r, not \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n\t\t} else {\n\t\t\t// \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n\t\t}\n\n\t\tconst prevNewLength = prev.piece.length - 1;\n\t\tconst prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n\t\tprev.piece = new Piece(\n\t\t\tprev.piece.bufferIndex,\n\t\t\tprev.piece.start,\n\t\t\tnewEnd,\n\t\t\tprevNewLFCnt,\n\t\t\tprevNewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, prev, - 1, -1);\n\t\tif (prev.piece.length === 0) {\n\t\t\tnodesToDel.push(prev);\n\t\t}\n\n\t\t// update nextNode\n\t\tconst newStart: BufferCursor = { line: next.piece.start.line + 1, column: 0 };\n\t\tconst newLength = next.piece.length - 1;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n\t\tnext.piece = new Piece(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, next, - 1, -1);\n\t\tif (next.piece.length === 0) {\n\t\t\tnodesToDel.push(next);\n\t\t}\n\n\t\t// create new piece which contains \\r\\n\n\t\tconst pieces = this.createNewPieces('\\r\\n');\n\t\tthis.rbInsertRight(prev, pieces[0]);\n\t\t// delete empty nodes\n\n\t\tfor (let i = 0; i < nodesToDel.length; i++) {\n\t\t\trbDelete(this, nodesToDel[i]);\n\t\t}\n\t}\n\n\tprivate adjustCarriageReturnFromNext(value: string, node: TreeNode): boolean {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\t// move `\\n` forward\n\t\t\t\tvalue += '\\n';\n\n\t\t\t\tif (nextNode.piece.length === 1) {\n\t\t\t\t\trbDelete(this, nextNode);\n\t\t\t\t} else {\n\n\t\t\t\t\tconst piece = nextNode.piece;\n\t\t\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\t\t\tconst newLength = piece.length - 1;\n\t\t\t\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\t\t\t\tnextNode.piece = new Piece(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t\tnewLineFeedCnt,\n\t\t\t\t\t\tnewLength\n\t\t\t\t\t);\n\n\t\t\t\t\tupdateTreeMetadata(this, nextNode, -1, -1);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// #endregion\n\n\t// #endregion\n\n\t// #region Tree operations\n\titerate(node: TreeNode, callback: (node: TreeNode) => boolean): boolean {\n\t\tif (node === SENTINEL) {\n\t\t\treturn callback(SENTINEL);\n\t\t}\n\n\t\tconst leftRet = this.iterate(node.left, callback);\n\t\tif (!leftRet) {\n\t\t\treturn leftRet;\n\t\t}\n\n\t\treturn callback(node) && this.iterate(node.right, callback);\n\t}\n\n\tprivate getNodeContent(node: TreeNode) {\n\t\tif (node === SENTINEL) {\n\t\t\treturn '';\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst piece = node.piece;\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\tgetPieceContent(piece: Piece) {\n\t\tconst buffer = this._buffers[piece.bufferIndex];\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b    <----   a    b\n\t *                         /\n\t *                        z\n\t */\n\tprivate rbInsertRight(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tconst x = this.root;\n\t\tif (x === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.right === SENTINEL) {\n\t\t\tnode!.right = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst nextNode = leftest(node!.right);\n\t\t\tnextNode.left = z;\n\t\t\tz.parent = nextNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b     ---->   a    b\n\t *                       \\\n\t *                        z\n\t */\n\tprivate rbInsertLeft(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tif (this.root === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.left === SENTINEL) {\n\t\t\tnode!.left = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst prevNode = righttest(node!.left); // a\n\t\t\tprevNode.right = z;\n\t\t\tz.parent = prevNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\tprivate getContentOfSubTree(node: TreeNode): string {\n\t\tlet str = '';\n\n\t\tthis.iterate(node, node => {\n\t\t\tstr += this.getNodeContent(node);\n\t\t\treturn true;\n\t\t});\n\n\t\treturn str;\n\t}\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport * as strings from 'vs/base/common/strings';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer, ITextSnapshot, ValidAnnotatedEditOperation, IValidEditOperation, SearchData } from 'vs/editor/common/model';\nimport { PieceTreeBase, StringBuffer } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\nimport { countEOL, StringEOL } from 'vs/editor/common/core/eolCounter';\nimport { TextChange } from 'vs/editor/common/core/textChange';\nimport { Disposable } from 'vs/base/common/lifecycle';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\nexport interface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeContent: Event<void> = this._onDidChangeContent.event;\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, containsUnusualLineTerminators: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\n\t// #region TextBuffer\n\tpublic equals(other: ITextBuffer): boolean {\n\t\tif (!(other instanceof PieceTreeTextBuffer)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._BOM !== other._BOM) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getEOL() !== other.getEOL()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._pieceTree.equal(other._pieceTree);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\t\treturn endOffset - startOffset;\n\t}\n\n\tpublic getCharacterCountInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n\t\t\t\tconst toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\treturn this._pieceTree.getCharCode(offset);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\treturn this.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown EOL preference');\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = '';\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL = (bufferEOL === '\\r\\n' ? StringEOL.CRLF : StringEOL.LF);\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n\t\tconst newTrimAutoWhitespaceCandidates: { lineNumber: number; oldContent: string }[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += (op.text.length - bufferText.length);\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tconst lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join('');\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t// #endregion\n\n\t// #region helper\n\t// testing purpose.\n\tpublic getPieceTree(): PieceTreeBase {\n\t\treturn this._pieceTree;\n\t}\n\n\tpublic static _getInverseEditRange(range: Range, text: string) {\n\t\tconst startLineNumber = range.startLineNumber;\n\t\tconst startColumn = range.startColumn;\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tlet resultRange: Range;\n\n\t\tif (text.length > 0) {\n\t\t\t// the operation inserts something\n\t\t\tconst lineCount = eolCount + 1;\n\n\t\t\tif (lineCount === 1) {\n\t\t\t\t// single line insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLineLength);\n\t\t\t} else {\n\t\t\t\t// multi line insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLineLength + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// There is nothing to insert\n\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t}\n\n\t\treturn resultRange;\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport * as strings from 'vs/base/common/strings';\nimport { DefaultEndOfLine, ITextBuffer, ITextBufferBuilder, ITextBufferFactory } from 'vs/editor/common/model';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\nimport { PieceTreeTextBuffer } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer';\n\nexport class PieceTreeTextBufferFactory implements ITextBufferFactory {\n\n\tconstructor(\n\t\tprivate readonly _chunks: StringBuffer[],\n\t\tprivate readonly _bom: string,\n\t\tprivate readonly _cr: number,\n\t\tprivate readonly _lf: number,\n\t\tprivate readonly _crlf: number,\n\t\tprivate readonly _containsRTL: boolean,\n\t\tprivate readonly _containsUnusualLineTerminators: boolean,\n\t\tprivate readonly _isBasicASCII: boolean,\n\t\tprivate readonly _normalizeEOL: boolean\n\t) { }\n\n\tprivate _getEOL(defaultEOL: DefaultEndOfLine): '\\r\\n' | '\\n' {\n\t\tconst totalEOLCount = this._cr + this._lf + this._crlf;\n\t\tconst totalCRCount = this._cr + this._crlf;\n\t\tif (totalEOLCount === 0) {\n\t\t\t// This is an empty file or a file with precisely one line\n\t\t\treturn (defaultEOL === DefaultEndOfLine.LF ? '\\n' : '\\r\\n');\n\t\t}\n\t\tif (totalCRCount > totalEOLCount / 2) {\n\t\t\t// More than half of the file contains \\r\\n ending lines\n\t\t\treturn '\\r\\n';\n\t\t}\n\t\t// At least one line more ends in \\n\n\t\treturn '\\n';\n\t}\n\n\tpublic create(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable } {\n\t\tconst eol = this._getEOL(defaultEOL);\n\t\tconst chunks = this._chunks;\n\n\t\tif (this._normalizeEOL &&\n\t\t\t((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n\t\t\t\t|| (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))\n\t\t) {\n\t\t\t// Normalize pieces\n\t\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\tconst str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t\tconst newLineStart = createLineStartsFast(str);\n\t\t\t\tchunks[i] = new StringBuffer(str, newLineStart);\n\t\t\t}\n\t\t}\n\n\t\tconst textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n\t\treturn { textBuffer: textBuffer, disposable: textBuffer };\n\t}\n\n\tpublic getFirstLineText(lengthLimit: number): string {\n\t\treturn this._chunks[0].buffer.substr(0, lengthLimit).split(/\\r\\n|\\r|\\n/)[0];\n\t}\n}\n\nexport class PieceTreeTextBufferBuilder implements ITextBufferBuilder {\n\tprivate readonly chunks: StringBuffer[];\n\tprivate BOM: string;\n\n\tprivate _hasPreviousChar: boolean;\n\tprivate _previousChar: number;\n\tprivate readonly _tmpLineStarts: number[];\n\n\tprivate cr: number;\n\tprivate lf: number;\n\tprivate crlf: number;\n\tprivate containsRTL: boolean;\n\tprivate containsUnusualLineTerminators: boolean;\n\tprivate isBasicASCII: boolean;\n\n\tconstructor() {\n\t\tthis.chunks = [];\n\t\tthis.BOM = '';\n\n\t\tthis._hasPreviousChar = false;\n\t\tthis._previousChar = 0;\n\t\tthis._tmpLineStarts = [];\n\n\t\tthis.cr = 0;\n\t\tthis.lf = 0;\n\t\tthis.crlf = 0;\n\t\tthis.containsRTL = false;\n\t\tthis.containsUnusualLineTerminators = false;\n\t\tthis.isBasicASCII = true;\n\t}\n\n\tpublic acceptChunk(chunk: string): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.chunks.length === 0) {\n\t\t\tif (strings.startsWithUTF8BOM(chunk)) {\n\t\t\t\tthis.BOM = strings.UTF8_BOM_CHARACTER;\n\t\t\t\tchunk = chunk.substr(1);\n\t\t\t}\n\t\t}\n\n\t\tconst lastChar = chunk.charCodeAt(chunk.length - 1);\n\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\tthis._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\t\t\tthis._hasPreviousChar = true;\n\t\t\tthis._previousChar = lastChar;\n\t\t} else {\n\t\t\tthis._acceptChunk1(chunk, false);\n\t\t\tthis._hasPreviousChar = false;\n\t\t\tthis._previousChar = lastChar;\n\t\t}\n\t}\n\n\tprivate _acceptChunk1(chunk: string, allowEmptyStrings: boolean): void {\n\t\tif (!allowEmptyStrings && chunk.length === 0) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n\t\t} else {\n\t\t\tthis._acceptChunk2(chunk);\n\t\t}\n\t}\n\n\tprivate _acceptChunk2(chunk: string): void {\n\t\tconst lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n\n\t\tthis.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n\t\tthis.cr += lineStarts.cr;\n\t\tthis.lf += lineStarts.lf;\n\t\tthis.crlf += lineStarts.crlf;\n\n\t\tif (this.isBasicASCII) {\n\t\t\tthis.isBasicASCII = lineStarts.isBasicASCII;\n\t\t}\n\t\tif (!this.isBasicASCII && !this.containsRTL) {\n\t\t\t// No need to check if it is basic ASCII\n\t\t\tthis.containsRTL = strings.containsRTL(chunk);\n\t\t}\n\t\tif (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n\t\t\t// No need to check if it is basic ASCII\n\t\t\tthis.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n\t\t}\n\t}\n\n\tpublic finish(normalizeEOL: boolean = true): PieceTreeTextBufferFactory {\n\t\tthis._finish();\n\t\treturn new PieceTreeTextBufferFactory(\n\t\t\tthis.chunks,\n\t\t\tthis.BOM,\n\t\t\tthis.cr,\n\t\t\tthis.lf,\n\t\t\tthis.crlf,\n\t\t\tthis.containsRTL,\n\t\t\tthis.containsUnusualLineTerminators,\n\t\t\tthis.isBasicASCII,\n\t\t\tnormalizeEOL\n\t\t);\n\t}\n\n\tprivate _finish(): void {\n\t\tif (this.chunks.length === 0) {\n\t\t\tthis._acceptChunk1('', true);\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._hasPreviousChar = false;\n\t\t\t// recreate last chunk\n\t\t\tconst lastChunk = this.chunks[this.chunks.length - 1];\n\t\t\tlastChunk.buffer += String.fromCharCode(this._previousChar);\n\t\t\tconst newLineStarts = createLineStartsFast(lastChunk.buffer);\n\t\t\tlastChunk.lineStarts = newLineStarts;\n\t\t\tif (this._previousChar === CharCode.CarriageReturn) {\n\t\t\t\tthis.cr++;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as descriptors from './descriptors';\nimport { ServiceCollection } from './serviceCollection';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\ntype GetLeadingNonServiceArgs<Args> =\n\tArgs extends [...BrandedService[]] ? []\n\t: Args extends [infer A, ...BrandedService[]] ? [A]\n\t: Args extends [infer A, ...infer R] ? [A, ...GetLeadingNonServiceArgs<R>]\n\t: never;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(serviceIdentifier: ServiceIdentifier<T1>): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from 'vs/base/common/platform';\nimport { isFalsyOrWhitespace } from 'vs/base/common/strings';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nconst CONSTANT_VALUES = new Map<string, boolean>();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport const enum ContextKeyExprType {\n\tFalse = 0,\n\tTrue = 1,\n\tDefined = 2,\n\tNot = 3,\n\tEquals = 4,\n\tNotEquals = 5,\n\tAnd = 6,\n\tRegex = 7,\n\tNotRegex = 8,\n\tOr = 9,\n\tIn = 10,\n\tNotIn = 11,\n\tGreater = 12,\n\tGreaterEquals = 13,\n\tSmaller = 14,\n\tSmallerEquals = 15,\n}\n\nexport interface IContextKeyExprMapper {\n\tmapDefined(key: string): ContextKeyExpression;\n\tmapNot(key: string): ContextKeyExpression;\n\tmapEquals(key: string, value: any): ContextKeyExpression;\n\tmapNotEquals(key: string, value: any): ContextKeyExpression;\n\tmapGreater(key: string, value: any): ContextKeyExpression;\n\tmapGreaterEquals(key: string, value: any): ContextKeyExpression;\n\tmapSmaller(key: string, value: any): ContextKeyExpression;\n\tmapSmallerEquals(key: string, value: any): ContextKeyExpression;\n\tmapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;\n\tmapIn(key: string, valueKey: string): ContextKeyInExpr;\n\tmapNotIn(key: string, valueKey: string): ContextKeyNotInExpr;\n}\n\nexport interface IContextKeyExpression {\n\tcmp(other: ContextKeyExpression): number;\n\tequals(other: ContextKeyExpression): boolean;\n\tsubstituteConstants(): ContextKeyExpression | undefined;\n\tevaluate(context: IContext): boolean;\n\tserialize(): string;\n\tkeys(): string[];\n\tmap(mapFnc: IContextKeyExprMapper): ContextKeyExpression;\n\tnegate(): ContextKeyExpression;\n\n}\n\nexport type ContextKeyExpression = (\n\tContextKeyFalseExpr | ContextKeyTrueExpr | ContextKeyDefinedExpr | ContextKeyNotExpr\n\t| ContextKeyEqualsExpr | ContextKeyNotEqualsExpr | ContextKeyRegexExpr\n\t| ContextKeyNotRegexExpr | ContextKeyAndExpr | ContextKeyOrExpr | ContextKeyInExpr\n\t| ContextKeyNotInExpr | ContextKeyGreaterExpr | ContextKeyGreaterEqualsExpr\n\t| ContextKeySmallerExpr | ContextKeySmallerEqualsExpr\n);\n\nexport abstract class ContextKeyExpr {\n\n\tpublic static false(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n\tpublic static true(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n\tpublic static has(key: string): ContextKeyExpression {\n\t\treturn ContextKeyDefinedExpr.create(key);\n\t}\n\tpublic static equals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(key, value);\n\t}\n\tpublic static notEquals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(key, value);\n\t}\n\tpublic static regex(key: string, value: RegExp): ContextKeyExpression {\n\t\treturn ContextKeyRegexExpr.create(key, value);\n\t}\n\tpublic static in(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyInExpr.create(key, value);\n\t}\n\tpublic static notIn(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyNotInExpr.create(key, value);\n\t}\n\tpublic static not(key: string): ContextKeyExpression {\n\t\treturn ContextKeyNotExpr.create(key);\n\t}\n\tpublic static and(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr.create(expr, null);\n\t}\n\tpublic static or(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr.create(expr, null, true);\n\t}\n\tpublic static greater(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterExpr.create(key, value);\n\t}\n\tpublic static greaterEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterEqualsExpr.create(key, value);\n\t}\n\tpublic static smaller(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerExpr.create(key, value);\n\t}\n\tpublic static smallerEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerEqualsExpr.create(key, value);\n\t}\n\n\tpublic static deserialize(serialized: string | null | undefined, strict: boolean = false): ContextKeyExpression | undefined {\n\t\tif (!serialized) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._deserializeOrExpression(serialized, strict);\n\t}\n\n\tprivate static _deserializeOrExpression(serialized: string, strict: boolean): ContextKeyExpression | undefined {\n\t\tconst pieces = serialized.split('||');\n\t\treturn ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n\t}\n\n\tprivate static _deserializeAndExpression(serialized: string, strict: boolean): ContextKeyExpression | undefined {\n\t\tconst pieces = serialized.split('&&');\n\t\treturn ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n\t}\n\n\tprivate static _deserializeOne(serializedOne: string, strict: boolean): ContextKeyExpression {\n\t\tserializedOne = serializedOne.trim();\n\n\t\tif (serializedOne.indexOf('!=') >= 0) {\n\t\t\tconst pieces = serializedOne.split('!=');\n\t\t\treturn ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n\t\t}\n\n\t\tif (serializedOne.indexOf('==') >= 0) {\n\t\t\tconst pieces = serializedOne.split('==');\n\t\t\treturn ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n\t\t}\n\n\t\tif (serializedOne.indexOf('=~') >= 0) {\n\t\t\tconst pieces = serializedOne.split('=~');\n\t\t\treturn ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n\t\t}\n\n\t\tif (serializedOne.indexOf(' not in ') >= 0) {\n\t\t\tconst pieces = serializedOne.split(' not in ');\n\t\t\treturn ContextKeyNotInExpr.create(pieces[0].trim(), pieces[1].trim());\n\t\t}\n\n\t\tif (serializedOne.indexOf(' in ') >= 0) {\n\t\t\tconst pieces = serializedOne.split(' in ');\n\t\t\treturn ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n\t\t}\n\n\t\tif (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n\t\t\tconst pieces = serializedOne.split('>=');\n\t\t\treturn ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n\t\t}\n\n\t\tif (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n\t\t\tconst pieces = serializedOne.split('>');\n\t\t\treturn ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n\t\t}\n\n\t\tif (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n\t\t\tconst pieces = serializedOne.split('<=');\n\t\t\treturn ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n\t\t}\n\n\t\tif (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n\t\t\tconst pieces = serializedOne.split('<');\n\t\t\treturn ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n\t\t}\n\n\t\tif (/^\\!\\s*/.test(serializedOne)) {\n\t\t\treturn ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n\t\t}\n\n\t\treturn ContextKeyDefinedExpr.create(serializedOne);\n\t}\n\n\tprivate static _deserializeValue(serializedValue: string, strict: boolean): any {\n\t\tserializedValue = serializedValue.trim();\n\n\t\tif (serializedValue === 'true') {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (serializedValue === 'false') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst m = /^'([^']*)'$/.exec(serializedValue);\n\t\tif (m) {\n\t\t\treturn m[1].trim();\n\t\t}\n\n\t\treturn serializedValue;\n\t}\n\n\tprivate static _deserializeRegexValue(serializedValue: string, strict: boolean): RegExp | null {\n\n\t\tif (isFalsyOrWhitespace(serializedValue)) {\n\t\t\tif (strict) {\n\t\t\t\tthrow new Error('missing regexp-value for =~-expression');\n\t\t\t} else {\n\t\t\t\tconsole.warn('missing regexp-value for =~-expression');\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst start = serializedValue.indexOf('/');\n\t\tconst end = serializedValue.lastIndexOf('/');\n\t\tif (start === end || start < 0 /* || to < 0 */) {\n\t\t\tif (strict) {\n\t\t\t\tthrow new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst value = serializedValue.slice(start + 1, end);\n\t\tconst caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\t\ttry {\n\t\t\treturn new RegExp(value, caseIgnoreFlag);\n\t\t} catch (e) {\n\t\t\tif (strict) {\n\t\t\t\tthrow new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\nexport function expressionsAreEqualWithConstantSubstitution(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\tconst aExpr = a ? a.substituteConstants() : undefined;\n\tconst bExpr = b ? b.substituteConstants() : undefined;\n\tif (!aExpr && !bExpr) {\n\t\treturn true;\n\t}\n\tif (!aExpr || !bExpr) {\n\t\treturn false;\n\t}\n\treturn aExpr.equals(bExpr);\n}\n\nfunction cmp(a: ContextKeyExpression, b: ContextKeyExpression): number {\n\treturn a.cmp(b);\n}\n\nexport class ContextKeyFalseExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyFalseExpr();\n\n\tpublic readonly type = ContextKeyExprType.False;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'false';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyTrueExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyTrueExpr();\n\n\tpublic readonly type = ContextKeyExprType.True;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'true';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyDefinedExpr implements IContextKeyExpression {\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyDefinedExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Defined;\n\n\tprotected constructor(\n\t\treadonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.key;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapDefined(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\treturn (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Equals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional ==\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) == this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} == '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyInExpr {\n\t\treturn new ContextKeyInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.In;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.valueKey, other.key, other.valueKey);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.valueKey === other.valueKey);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst source = context.getValue(this.valueKey);\n\n\t\tconst item = context.getValue(this.key);\n\n\t\tif (Array.isArray(source)) {\n\t\t\treturn source.includes(item as any);\n\t\t}\n\n\t\tif (typeof item === 'string' && typeof source === 'object' && source !== null) {\n\t\t\treturn hasOwnProperty.call(source, item);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key, this.valueKey];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyInExpr {\n\t\treturn mapFnc.mapIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyNotInExpr {\n\t\treturn new ContextKeyNotInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotIn;\n\n\tprivate readonly _negated: ContextKeyInExpr;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t\tthis._negated = ContextKeyInExpr.create(key, valueKey);\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._negated.cmp(other._negated);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._negated.equals(other._negated);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._negated.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} not in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._negated.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._negated;\n\t}\n}\n\nexport class ContextKeyNotEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\tif (value) {\n\t\t\t\treturn ContextKeyNotExpr.create(key, negated);\n\t\t\t}\n\t\t\treturn ContextKeyDefinedExpr.create(key, negated);\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional !=\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) != this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} != '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Not;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!${this.key}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNot(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyDefinedExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nfunction withFloatOrStr<T extends ContextKeyExpression>(value: any, callback: (value: number | string) => T): T | ContextKeyFalseExpr {\n\tif (typeof value === 'string') {\n\t\tconst n = parseFloat(value);\n\t\tif (!isNaN(n)) {\n\t\t\tvalue = n;\n\t\t}\n\t}\n\tif (typeof value === 'string' || typeof value === 'number') {\n\t\treturn callback(value);\n\t}\n\treturn ContextKeyFalseExpr.INSTANCE;\n}\n\nexport class ContextKeyGreaterExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Greater;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) > this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} > ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreater(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyGreaterEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.GreaterEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) >= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} >= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreaterEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Smaller;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) < this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} < ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmaller(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.SmallerEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) <= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} <= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmallerEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, regexp: RegExp | null): ContextKeyRegexExpr {\n\t\treturn new ContextKeyRegexExpr(key, regexp);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Regex;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly regexp: RegExp | null\n\t) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\tif (thisSource < otherSource) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (thisSource > otherSource) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\t\treturn (this.key === other.key && thisSource === otherSource);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst value = context.getValue<any>(this.key);\n\t\treturn this.regexp ? this.regexp.test(value) : false;\n\t}\n\n\tpublic serialize(): string {\n\t\tconst value = this.regexp\n\t\t\t? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n\t\t\t: '/invalid/';\n\t\treturn `${this.key} =~ ${value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyRegexExpr {\n\t\treturn mapFnc.mapRegex(this.key, this.regexp);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotRegexExpr.create(this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(actual: ContextKeyRegexExpr): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(actual);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotRegex;\n\n\tprivate constructor(private readonly _actual: ContextKeyRegexExpr) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._actual.cmp(other._actual);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._actual.equals(other._actual);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._actual.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._actual.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(this._actual.map(mapFnc));\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._actual;\n\t}\n}\n\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr: ContextKeyExpression[]): (ContextKeyExpression | undefined)[] {\n\t// Allocate array only if there is a difference\n\tlet newArr: (ContextKeyExpression | undefined)[] | null = null;\n\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\tconst newExpr = arr[i].substituteConstants();\n\n\t\tif (arr[i] !== newExpr) {\n\t\t\t// something has changed!\n\n\t\t\t// allocate array on first difference\n\t\t\tif (newArr === null) {\n\t\t\t\tnewArr = [];\n\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\tnewArr[j] = arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newArr !== null) {\n\t\t\tnewArr[i] = newExpr;\n\t\t}\n\t}\n\n\tif (newArr === null) {\n\t\treturn arr;\n\t}\n\treturn newArr;\n}\n\nclass ContextKeyAndExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr._normalizeArr(_expr, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.And;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyAndExpr.create(exprArr, this.negated);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (!this.expr[i].evaluate(context)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null): ContextKeyExpression | undefined {\n\t\tconst expr: ContextKeyExpression[] = [];\n\t\tlet hasTrue = false;\n\n\t\tfor (const e of arr) {\n\t\t\tif (!e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t// anything && true ==> anything\n\t\t\t\thasTrue = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t// anything && false ==> false\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.And) {\n\t\t\t\texpr.push(...e.expr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texpr.push(e);\n\t\t}\n\n\t\tif (expr.length === 0 && hasTrue) {\n\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\texpr.sort(cmp);\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// We must distribute any OR expression because we don't support parens\n\t\t// OR extensions will be at the end (due to sorting rules)\n\t\twhile (expr.length > 1) {\n\t\t\tconst lastElement = expr[expr.length - 1];\n\t\t\tif (lastElement.type !== ContextKeyExprType.Or) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// pop the last element\n\t\t\texpr.pop();\n\n\t\t\t// pop the second to last element\n\t\t\tconst secondToLastElement = expr.pop()!;\n\n\t\t\tconst isFinished = (expr.length === 0);\n\n\t\t\t// distribute `lastElement` over `secondToLastElement`\n\t\t\tconst resultElement = ContextKeyOrExpr.create(\n\t\t\t\tlastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)),\n\t\t\t\tnull,\n\t\t\t\tisFinished\n\t\t\t);\n\n\t\t\tif (resultElement) {\n\t\t\t\texpr.push(resultElement);\n\t\t\t\texpr.sort(cmp);\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\treturn new ContextKeyAndExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' && ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nclass ContextKeyOrExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Or;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyOrExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (this.expr[i].evaluate(context)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\tlet expr: ContextKeyExpression[] = [];\n\t\tlet hasFalse = false;\n\n\t\tif (arr) {\n\t\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\t\tconst e = arr[i];\n\t\t\t\tif (!e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t\t// anything || false ==> anything\n\t\t\t\t\thasFalse = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t\t// anything || true ==> true\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.Or) {\n\t\t\t\t\texpr = expr.concat(e.expr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texpr.push(e);\n\t\t\t}\n\n\t\t\tif (expr.length === 0 && hasFalse) {\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\texpr.sort(cmp);\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// eliminate redundant terms\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (implies(expr[i], expr[j])) {\n\t\t\t\t\t\texpr.splice(j, 1);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyOrExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' || ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyOrExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\n\t\t\t// We don't support parens, so here we distribute the AND over the OR terminals\n\t\t\t// We always take the first 2 AND pairs and distribute them\n\t\t\twhile (result.length > 1) {\n\t\t\t\tconst LEFT = result.shift()!;\n\t\t\t\tconst RIGHT = result.shift()!;\n\n\t\t\t\tconst all: ContextKeyExpression[] = [];\n\t\t\t\tfor (const left of getTerminals(LEFT)) {\n\t\t\t\t\tfor (const right of getTerminals(RIGHT)) {\n\t\t\t\t\t\tall.push(ContextKeyAndExpr.create([left, right], null)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst isFinished = (result.length === 0);\n\t\t\t\tresult.unshift(ContextKeyOrExpr.create(all, null, isFinished)!);\n\t\t\t}\n\n\t\t\tthis.negated = result[0];\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport interface ContextKeyInfo {\n\treadonly key: string;\n\treadonly type?: string;\n\treadonly description?: string;\n}\n\nexport class RawContextKey<T extends ContextKeyValue> extends ContextKeyDefinedExpr {\n\n\tprivate static _info: ContextKeyInfo[] = [];\n\n\tstatic all(): IterableIterator<ContextKeyInfo> {\n\t\treturn RawContextKey._info.values();\n\t}\n\n\tprivate readonly _defaultValue: T | undefined;\n\n\tconstructor(key: string, defaultValue: T | undefined, metaOrHide?: string | true | { type: string; description: string }) {\n\t\tsuper(key, null);\n\t\tthis._defaultValue = defaultValue;\n\n\t\t// collect all context keys into a central place\n\t\tif (typeof metaOrHide === 'object') {\n\t\t\tRawContextKey._info.push({ ...metaOrHide, key });\n\t\t} else if (metaOrHide !== true) {\n\t\t\tRawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n\t\t}\n\t}\n\n\tpublic bindTo(target: IContextKeyService): IContextKey<T> {\n\t\treturn target.createKey(this.key, this._defaultValue);\n\t}\n\n\tpublic getValue(target: IContextKeyService): T | undefined {\n\t\treturn target.getContextKeyValue<T>(this.key);\n\t}\n\n\tpublic toNegated(): ContextKeyExpression {\n\t\treturn this.negate();\n\t}\n\n\tpublic isEqualTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(this.key, value);\n\t}\n\n\tpublic notEqualsTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(this.key, value);\n\t}\n}\n\nexport type ContextKeyValue = null | undefined | boolean | number | string\n\t| Array<null | undefined | boolean | number | string>\n\t| Record<string, null | undefined | boolean | number | string>;\n\nexport interface IContext {\n\tgetValue<T extends ContextKeyValue = ContextKeyValue>(key: string): T | undefined;\n}\n\nexport interface IContextKey<T extends ContextKeyValue = ContextKeyValue> {\n\tset(value: T): void;\n\treset(): void;\n\tget(): T | undefined;\n}\n\nexport interface IContextKeyServiceTarget {\n\tparentElement: IContextKeyServiceTarget | null;\n\tsetAttribute(attr: string, value: string): void;\n\tremoveAttribute(attr: string): void;\n\thasAttribute(attr: string): boolean;\n\tgetAttribute(attr: string): string | null;\n}\n\nexport const IContextKeyService = createDecorator<IContextKeyService>('contextKeyService');\n\nexport interface IReadableSet<T> {\n\thas(value: T): boolean;\n}\n\nexport interface IContextKeyChangeEvent {\n\taffectsSome(keys: IReadableSet<string>): boolean;\n\tallKeysContainedIn(keys: IReadableSet<string>): boolean;\n}\n\nexport interface IContextKeyService {\n\treadonly _serviceBrand: undefined;\n\tdispose(): void;\n\n\tonDidChangeContext: Event<IContextKeyChangeEvent>;\n\tbufferChangeEvents(callback: Function): void;\n\n\tcreateKey<T extends ContextKeyValue>(key: string, defaultValue: T | undefined): IContextKey<T>;\n\tcontextMatchesRules(rules: ContextKeyExpression | undefined): boolean;\n\tgetContextKeyValue<T>(key: string): T | undefined;\n\n\tcreateScoped(target: IContextKeyServiceTarget): IContextKeyService;\n\tcreateOverlay(overlay: Iterable<[string, any]>): IContextKeyService;\n\tgetContext(target: IContextKeyServiceTarget | null): IContext;\n\n\tupdateParent(parentContextKeyService: IContextKeyService): void;\n}\n\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\n\nfunction cmp1(key1: string, key2: string): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction cmp2(key1: string, value1: any, key2: string, value2: any): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\tif (value1 < value2) {\n\t\treturn -1;\n\t}\n\tif (value1 > value2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p: ContextKeyExpression, q: ContextKeyExpression): boolean {\n\n\tif (q.type === ContextKeyExprType.And && (p.type !== ContextKeyExprType.Or && p.type !== ContextKeyExprType.And)) {\n\t\t// covers the case: A implies A && B\n\t\tfor (const qTerm of q.expr) {\n\t\t\tif (p.equals(qTerm)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst notP = p.negate();\n\tconst expr = getTerminals(notP).concat(getTerminals(q));\n\texpr.sort(cmp);\n\n\tfor (let i = 0; i < expr.length; i++) {\n\t\tconst a = expr[i];\n\t\tconst notA = a.negate();\n\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\tconst b = expr[j];\n\t\t\tif (notA.equals(b)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction getTerminals(node: ContextKeyExpression) {\n\tif (node.type === ContextKeyExprType.Or) {\n\t\treturn node.expr;\n\t}\n\treturn [node];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { decodeBase64, encodeBase64, VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IDiffResult } from 'vs/base/common/diff/diff';\nimport { Event } from 'vs/base/common/event';\nimport * as glob from 'vs/base/common/glob';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { Mimes } from 'vs/base/common/mime';\nimport { Schemas } from 'vs/base/common/network';\nimport { basename } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { ISplice } from 'vs/base/common/sequence';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { ILineChange } from 'vs/editor/common/diff/diffComputer';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { Command, WorkspaceEditMetadata } from 'vs/editor/common/languages';\nimport { IReadonlyTextBuffer } from 'vs/editor/common/model';\nimport { IAccessibilityInformation } from 'vs/platform/accessibility/common/accessibility';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { IEditorModel } from 'vs/platform/editor/common/editor';\nimport { ExtensionIdentifier } from 'vs/platform/extensions/common/extensions';\nimport { ThemeColor } from 'vs/platform/theme/common/themeService';\nimport { UndoRedoGroup } from 'vs/platform/undoRedo/common/undoRedo';\nimport { IRevertOptions, ISaveOptions, IUntypedEditorInput } from 'vs/workbench/common/editor';\nimport { NotebookTextModel } from 'vs/workbench/contrib/notebook/common/model/notebookTextModel';\nimport { ICellRange } from 'vs/workbench/contrib/notebook/common/notebookRange';\nimport { IWorkingCopyBackupMeta, IWorkingCopySaveEvent } from 'vs/workbench/services/workingCopy/common/workingCopy';\n\nexport const NOTEBOOK_EDITOR_ID = 'workbench.editor.notebook';\nexport const NOTEBOOK_DIFF_EDITOR_ID = 'workbench.editor.notebookTextDiffEditor';\n\n\nexport enum CellKind {\n\tMarkup = 1,\n\tCode = 2\n}\n\nexport const NOTEBOOK_DISPLAY_ORDER: readonly string[] = [\n\t'application/json',\n\t'application/javascript',\n\t'text/html',\n\t'image/svg+xml',\n\tMimes.latex,\n\tMimes.markdown,\n\t'image/png',\n\t'image/jpeg',\n\tMimes.text\n];\n\nexport const ACCESSIBLE_NOTEBOOK_DISPLAY_ORDER: readonly string[] = [\n\tMimes.latex,\n\tMimes.markdown,\n\t'application/json',\n\tMimes.text,\n\t'text/html',\n\t'image/svg+xml',\n\t'image/png',\n\t'image/jpeg',\n];\n\n/**\n * A mapping of extension IDs who contain renderers, to notebook ids who they\n * should be treated as the same in the renderer selection logic. This is used\n * to prefer the 1st party Jupyter renderers even though they're in a separate\n * extension, for instance. See #136247.\n */\nexport const RENDERER_EQUIVALENT_EXTENSIONS: ReadonlyMap<string, ReadonlySet<string>> = new Map([\n\t['ms-toolsai.jupyter', new Set(['jupyter-notebook', 'interactive'])],\n\t['ms-toolsai.jupyter-renderers', new Set(['jupyter-notebook', 'interactive'])],\n]);\n\nexport const RENDERER_NOT_AVAILABLE = '_notAvailable';\n\nexport type NotebookRendererEntrypoint = string | { readonly extends: string; readonly path: string };\n\nexport enum NotebookRunState {\n\tRunning = 1,\n\tIdle = 2\n}\n\nexport type NotebookDocumentMetadata = Record<string, unknown>;\n\nexport enum NotebookCellExecutionState {\n\tUnconfirmed = 1,\n\tPending = 2,\n\tExecuting = 3\n}\n\nexport interface INotebookCellPreviousExecutionResult {\n\texecutionOrder?: number;\n\tsuccess?: boolean;\n\tduration?: number;\n}\n\nexport interface NotebookCellMetadata {\n\t/**\n\t * custom metadata\n\t */\n\t[key: string]: unknown;\n}\n\nexport interface NotebookCellInternalMetadata {\n\texecutionOrder?: number;\n\tlastRunSuccess?: boolean;\n\trunStartTime?: number;\n\trunStartTimeAdjustment?: number;\n\trunEndTime?: number;\n}\n\nexport interface NotebookCellCollapseState {\n\tinputCollapsed?: boolean;\n\toutputCollapsed?: boolean;\n}\n\nexport interface NotebookCellDefaultCollapseConfig {\n\tcodeCell?: NotebookCellCollapseState;\n\tmarkupCell?: NotebookCellCollapseState;\n}\n\nexport type InteractiveWindowCollapseCodeCells = 'always' | 'never' | 'fromEditor';\n\nexport type TransientCellMetadata = { [K in keyof NotebookCellMetadata]?: boolean };\nexport type TransientDocumentMetadata = { [K in keyof NotebookDocumentMetadata]?: boolean };\n\nexport interface TransientOptions {\n\ttransientOutputs: boolean;\n\ttransientCellMetadata: TransientCellMetadata;\n\ttransientDocumentMetadata: TransientDocumentMetadata;\n}\n\n/** Note: enum values are used for sorting */\nexport const enum NotebookRendererMatch {\n\t/** Renderer has a hard dependency on an available kernel */\n\tWithHardKernelDependency = 0,\n\t/** Renderer works better with an available kernel */\n\tWithOptionalKernelDependency = 1,\n\t/** Renderer is kernel-agnostic */\n\tPure = 2,\n\t/** Renderer is for a different mimeType or has a hard dependency which is unsatisfied */\n\tNever = 3,\n}\n\n/**\n * Renderer messaging requirement. While this allows for 'optional' messaging,\n * VS Code effectively treats it the same as true right now. \"Partial\n * activation\" of extensions is a very tricky problem, which could allow\n * solving this. But for now, optional is mostly only honored for aznb.\n */\nexport const enum RendererMessagingSpec {\n\tAlways = 'always',\n\tNever = 'never',\n\tOptional = 'optional',\n}\n\nexport interface INotebookRendererInfo {\n\tid: string;\n\tdisplayName: string;\n\textends?: string;\n\tentrypoint: URI;\n\tpreloads: ReadonlyArray<URI>;\n\textensionLocation: URI;\n\textensionId: ExtensionIdentifier;\n\tmessaging: RendererMessagingSpec;\n\n\treadonly mimeTypes: readonly string[];\n\n\treadonly dependencies: readonly string[];\n\n\treadonly isBuiltin: boolean;\n\n\tmatchesWithoutKernel(mimeType: string): NotebookRendererMatch;\n\tmatches(mimeType: string, kernelProvides: ReadonlyArray<string>): NotebookRendererMatch;\n}\n\n\nexport interface IOrderedMimeType {\n\tmimeType: string;\n\trendererId: string;\n\tisTrusted: boolean;\n}\n\nexport interface IOutputItemDto {\n\treadonly mime: string;\n\treadonly data: VSBuffer;\n}\n\nexport interface IOutputDto {\n\toutputs: IOutputItemDto[];\n\toutputId: string;\n\tmetadata?: Record<string, any>;\n}\n\nexport interface ICellOutput {\n\toutputs: IOutputItemDto[];\n\tmetadata?: Record<string, any>;\n\toutputId: string;\n\tonDidChangeData: Event<void>;\n\treplaceData(items: IOutputItemDto[]): void;\n\tappendData(items: IOutputItemDto[]): void;\n}\n\nexport interface CellInternalMetadataChangedEvent {\n\treadonly lastRunSuccessChanged?: boolean;\n}\n\nexport interface ICell {\n\treadonly uri: URI;\n\thandle: number;\n\tlanguage: string;\n\tcellKind: CellKind;\n\toutputs: ICellOutput[];\n\tmetadata: NotebookCellMetadata;\n\tinternalMetadata: NotebookCellInternalMetadata;\n\tgetHashValue(): number;\n\ttextBuffer: IReadonlyTextBuffer;\n\tonDidChangeOutputs?: Event<NotebookCellOutputsSplice>;\n\tonDidChangeOutputItems?: Event<void>;\n\tonDidChangeLanguage: Event<string>;\n\tonDidChangeMetadata: Event<void>;\n\tonDidChangeInternalMetadata: Event<CellInternalMetadataChangedEvent>;\n}\n\nexport interface INotebookTextModel {\n\treadonly viewType: string;\n\tmetadata: NotebookDocumentMetadata;\n\treadonly transientOptions: TransientOptions;\n\treadonly uri: URI;\n\treadonly versionId: number;\n\treadonly length: number;\n\treadonly cells: readonly ICell[];\n\treset(cells: ICellDto2[], metadata: NotebookDocumentMetadata, transientOptions: TransientOptions): void;\n\tapplyEdits(rawEdits: ICellEditOperation[], synchronous: boolean, beginSelectionState: ISelectionState | undefined, endSelectionsComputer: () => ISelectionState | undefined, undoRedoGroup: UndoRedoGroup | undefined, computeUndoRedo?: boolean): boolean;\n\tonDidChangeContent: Event<NotebookTextModelChangedEvent>;\n\tonWillDispose: Event<void>;\n}\n\nexport type NotebookCellTextModelSplice<T> = [\n\tstart: number,\n\tdeleteCount: number,\n\tnewItems: T[]\n];\n\nexport type NotebookCellOutputsSplice = {\n\tstart: number /* start */;\n\tdeleteCount: number /* delete count */;\n\tnewOutputs: ICellOutput[];\n};\n\nexport interface IMainCellDto {\n\thandle: number;\n\turi: UriComponents;\n\tsource: string[];\n\teol: string;\n\tlanguage: string;\n\tcellKind: CellKind;\n\toutputs: IOutputDto[];\n\tmetadata?: NotebookCellMetadata;\n\tinternalMetadata?: NotebookCellInternalMetadata;\n}\n\nexport enum NotebookCellsChangeType {\n\tModelChange = 1,\n\tMove = 2,\n\tChangeCellLanguage = 5,\n\tInitialize = 6,\n\tChangeCellMetadata = 7,\n\tOutput = 8,\n\tOutputItem = 9,\n\tChangeCellContent = 10,\n\tChangeDocumentMetadata = 11,\n\tChangeCellInternalMetadata = 12,\n\tChangeCellMime = 13,\n\tUnknown = 100\n}\n\nexport interface NotebookCellsInitializeEvent<T> {\n\treadonly kind: NotebookCellsChangeType.Initialize;\n\treadonly changes: NotebookCellTextModelSplice<T>[];\n}\n\nexport interface NotebookCellContentChangeEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellContent;\n\treadonly index: number;\n}\n\nexport interface NotebookCellsModelChangedEvent<T> {\n\treadonly kind: NotebookCellsChangeType.ModelChange;\n\treadonly changes: NotebookCellTextModelSplice<T>[];\n}\n\nexport interface NotebookCellsModelMoveEvent<T> {\n\treadonly kind: NotebookCellsChangeType.Move;\n\treadonly index: number;\n\treadonly length: number;\n\treadonly newIdx: number;\n\treadonly cells: T[];\n}\n\nexport interface NotebookOutputChangedEvent {\n\treadonly kind: NotebookCellsChangeType.Output;\n\treadonly index: number;\n\treadonly outputs: IOutputDto[];\n\treadonly append: boolean;\n}\n\nexport interface NotebookOutputItemChangedEvent {\n\treadonly kind: NotebookCellsChangeType.OutputItem;\n\treadonly index: number;\n\treadonly outputId: string;\n\treadonly outputItems: IOutputItemDto[];\n\treadonly append: boolean;\n}\n\nexport interface NotebookCellsChangeLanguageEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellLanguage;\n\treadonly index: number;\n\treadonly language: string;\n}\n\nexport interface NotebookCellsChangeMimeEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellMime;\n\treadonly index: number;\n\treadonly mime: string | undefined;\n}\n\nexport interface NotebookCellsChangeMetadataEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellMetadata;\n\treadonly index: number;\n\treadonly metadata: NotebookCellMetadata;\n}\n\nexport interface NotebookCellsChangeInternalMetadataEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellInternalMetadata;\n\treadonly index: number;\n\treadonly internalMetadata: NotebookCellInternalMetadata;\n}\n\nexport interface NotebookDocumentChangeMetadataEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeDocumentMetadata;\n\treadonly metadata: NotebookDocumentMetadata;\n}\n\nexport interface NotebookDocumentUnknownChangeEvent {\n\treadonly kind: NotebookCellsChangeType.Unknown;\n}\n\nexport type NotebookRawContentEventDto = NotebookCellsInitializeEvent<IMainCellDto> | NotebookDocumentChangeMetadataEvent | NotebookCellContentChangeEvent | NotebookCellsModelChangedEvent<IMainCellDto> | NotebookCellsModelMoveEvent<IMainCellDto> | NotebookOutputChangedEvent | NotebookOutputItemChangedEvent | NotebookCellsChangeLanguageEvent | NotebookCellsChangeMimeEvent | NotebookCellsChangeMetadataEvent | NotebookCellsChangeInternalMetadataEvent | NotebookDocumentUnknownChangeEvent;\n\nexport type NotebookCellsChangedEventDto = {\n\treadonly rawEvents: NotebookRawContentEventDto[];\n\treadonly versionId: number;\n};\n\nexport type NotebookRawContentEvent = (NotebookCellsInitializeEvent<ICell> | NotebookDocumentChangeMetadataEvent | NotebookCellContentChangeEvent | NotebookCellsModelChangedEvent<ICell> | NotebookCellsModelMoveEvent<ICell> | NotebookOutputChangedEvent | NotebookOutputItemChangedEvent | NotebookCellsChangeLanguageEvent | NotebookCellsChangeMimeEvent | NotebookCellsChangeMetadataEvent | NotebookCellsChangeInternalMetadataEvent | NotebookDocumentUnknownChangeEvent) & { transient: boolean };\n\nexport enum SelectionStateType {\n\tHandle = 0,\n\tIndex = 1\n}\n\nexport interface ISelectionHandleState {\n\tkind: SelectionStateType.Handle;\n\tprimary: number | null;\n\tselections: number[];\n}\n\nexport interface ISelectionIndexState {\n\tkind: SelectionStateType.Index;\n\tfocus: ICellRange;\n\tselections: ICellRange[];\n}\n\nexport type ISelectionState = ISelectionHandleState | ISelectionIndexState;\n\nexport type NotebookTextModelChangedEvent = {\n\treadonly rawEvents: NotebookRawContentEvent[];\n\treadonly versionId: number;\n\treadonly synchronous: boolean | undefined;\n\treadonly endSelectionState: ISelectionState | undefined;\n};\n\nexport type NotebookTextModelWillAddRemoveEvent = {\n\treadonly rawEvent: NotebookCellsModelChangedEvent<ICell>;\n};\n\nexport const enum CellEditType {\n\tReplace = 1,\n\tOutput = 2,\n\tMetadata = 3,\n\tCellLanguage = 4,\n\tDocumentMetadata = 5,\n\tMove = 6,\n\tOutputItems = 7,\n\tPartialMetadata = 8,\n\tPartialInternalMetadata = 9,\n}\n\nexport interface ICellDto2 {\n\tsource: string;\n\tlanguage: string;\n\tmime: string | undefined;\n\tcellKind: CellKind;\n\toutputs: IOutputDto[];\n\tmetadata?: NotebookCellMetadata;\n\tinternalMetadata?: NotebookCellInternalMetadata;\n\tcollapseState?: NotebookCellCollapseState;\n}\n\nexport interface ICellReplaceEdit {\n\teditType: CellEditType.Replace;\n\tindex: number;\n\tcount: number;\n\tcells: ICellDto2[];\n}\n\nexport interface ICellOutputEdit {\n\teditType: CellEditType.Output;\n\tindex: number;\n\toutputs: IOutputDto[];\n\tappend?: boolean;\n}\n\nexport interface ICellOutputEditByHandle {\n\teditType: CellEditType.Output;\n\thandle: number;\n\toutputs: IOutputDto[];\n\tappend?: boolean;\n}\n\nexport interface ICellOutputItemEdit {\n\teditType: CellEditType.OutputItems;\n\toutputId: string;\n\titems: IOutputItemDto[];\n\tappend?: boolean;\n}\n\nexport interface ICellMetadataEdit {\n\teditType: CellEditType.Metadata;\n\tindex: number;\n\tmetadata: NotebookCellMetadata;\n}\n\n// These types are nullable because we need to use 'null' on the EH side so it is JSON-stringified\nexport type NullablePartialNotebookCellMetadata = {\n\t[Key in keyof Partial<NotebookCellMetadata>]: NotebookCellMetadata[Key] | null\n};\n\nexport interface ICellPartialMetadataEdit {\n\teditType: CellEditType.PartialMetadata;\n\tindex: number;\n\tmetadata: NullablePartialNotebookCellMetadata;\n}\n\nexport interface ICellPartialMetadataEditByHandle {\n\teditType: CellEditType.PartialMetadata;\n\thandle: number;\n\tmetadata: NullablePartialNotebookCellMetadata;\n}\n\nexport type NullablePartialNotebookCellInternalMetadata = {\n\t[Key in keyof Partial<NotebookCellInternalMetadata>]: NotebookCellInternalMetadata[Key] | null\n};\nexport interface ICellPartialInternalMetadataEdit {\n\teditType: CellEditType.PartialInternalMetadata;\n\tindex: number;\n\tinternalMetadata: NullablePartialNotebookCellInternalMetadata;\n}\n\nexport interface ICellPartialInternalMetadataEditByHandle {\n\teditType: CellEditType.PartialInternalMetadata;\n\thandle: number;\n\tinternalMetadata: NullablePartialNotebookCellInternalMetadata;\n}\n\nexport interface ICellLanguageEdit {\n\teditType: CellEditType.CellLanguage;\n\tindex: number;\n\tlanguage: string;\n}\n\nexport interface IDocumentMetadataEdit {\n\teditType: CellEditType.DocumentMetadata;\n\tmetadata: NotebookDocumentMetadata;\n}\n\nexport interface ICellMoveEdit {\n\teditType: CellEditType.Move;\n\tindex: number;\n\tlength: number;\n\tnewIdx: number;\n}\n\nexport type IImmediateCellEditOperation = ICellOutputEditByHandle | ICellPartialMetadataEditByHandle | ICellOutputItemEdit | ICellPartialInternalMetadataEdit | ICellPartialInternalMetadataEditByHandle | ICellPartialMetadataEdit;\nexport type ICellEditOperation = IImmediateCellEditOperation | ICellReplaceEdit | ICellOutputEdit | ICellMetadataEdit | ICellPartialMetadataEdit | ICellPartialInternalMetadataEdit | IDocumentMetadataEdit | ICellMoveEdit | ICellOutputItemEdit | ICellLanguageEdit;\n\n\nexport interface IWorkspaceNotebookCellEdit {\n\tmetadata?: WorkspaceEditMetadata;\n\tresource: URI;\n\tnotebookVersionId: number | undefined;\n\tcellEdit: ICellPartialMetadataEdit | IDocumentMetadataEdit | ICellReplaceEdit;\n}\n\nexport interface NotebookData {\n\treadonly cells: ICellDto2[];\n\treadonly metadata: NotebookDocumentMetadata;\n}\n\n\nexport interface INotebookContributionData {\n\textension?: ExtensionIdentifier;\n\tproviderDisplayName: string;\n\tdisplayName: string;\n\tfilenamePattern: (string | glob.IRelativePattern | INotebookExclusiveDocumentFilter)[];\n\texclusive: boolean;\n}\n\n\nexport namespace CellUri {\n\n\texport const scheme = Schemas.vscodeNotebookCell;\n\n\n\tconst _lengths = ['W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f'];\n\tconst _padRegexp = new RegExp(`^[${_lengths.join('')}]+`);\n\tconst _radix = 7;\n\n\texport function generate(notebook: URI, handle: number): URI {\n\n\t\tconst s = handle.toString(_radix);\n\t\tconst p = s.length < _lengths.length ? _lengths[s.length - 1] : 'z';\n\n\t\tconst fragment = `${p}${s}s${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;\n\t\treturn notebook.with({ scheme, fragment });\n\t}\n\n\texport function parse(cell: URI): { notebook: URI; handle: number } | undefined {\n\t\tif (cell.scheme !== scheme) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst idx = cell.fragment.indexOf('s');\n\t\tif (idx < 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ''), _radix);\n\t\tconst _scheme = decodeBase64(cell.fragment.substring(idx + 1)).toString();\n\n\t\tif (isNaN(handle)) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn {\n\t\t\thandle,\n\t\t\tnotebook: cell.with({ scheme: _scheme, fragment: null })\n\t\t};\n\t}\n\n\n\tconst _regex = /^(\\d{8,})(\\w[\\w\\d+.-]*)$/;\n\n\texport function generateCellOutputUri(notebook: URI, outputId?: string) {\n\t\treturn notebook.with({\n\t\t\tscheme: Schemas.vscodeNotebookCellOutput,\n\t\t\tfragment: `op${outputId ?? ''},${notebook.scheme !== Schemas.file ? notebook.scheme : ''}`\n\t\t});\n\t}\n\n\texport function parseCellOutputUri(uri: URI): { notebook: URI; outputId?: string } | undefined {\n\t\tif (uri.scheme !== Schemas.vscodeNotebookCellOutput) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\\,(.*)$/i.exec(uri.fragment);\n\t\tif (!match) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst outputId = (match[1] && match[1] !== '') ? match[1] : undefined;\n\t\tconst scheme = match[2];\n\t\treturn {\n\t\t\toutputId,\n\t\t\tnotebook: uri.with({\n\t\t\t\tscheme: scheme || Schemas.file,\n\t\t\t\tfragment: null\n\t\t\t})\n\t\t};\n\t}\n\n\texport function generateCellUri(notebook: URI, handle: number, scheme: string): URI {\n\t\treturn notebook.with({\n\t\t\tscheme: scheme,\n\t\t\tfragment: `ch${handle.toString().padStart(7, '0')}${notebook.scheme !== Schemas.file ? notebook.scheme : ''}`\n\t\t});\n\t}\n\n\texport function parseCellUri(metadata: URI, scheme: string) {\n\t\tif (metadata.scheme !== scheme) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst match = _regex.exec(metadata.fragment);\n\t\tif (!match) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst handle = Number(match[1]);\n\t\treturn {\n\t\t\thandle,\n\t\t\tnotebook: metadata.with({\n\t\t\t\tscheme: metadata.fragment.substring(match[0].length) || Schemas.file,\n\t\t\t\tfragment: null\n\t\t\t})\n\t\t};\n\t}\n}\n\nconst normalizeSlashes = (str: string) => isWindows ? str.replace(/\\//g, '\\\\') : str;\n\ninterface IMimeTypeWithMatcher {\n\tpattern: string;\n\tmatches: glob.ParsedPattern;\n}\n\nexport class MimeTypeDisplayOrder {\n\tprivate readonly order: IMimeTypeWithMatcher[];\n\n\tconstructor(\n\t\tinitialValue: readonly string[] = [],\n\t\tprivate readonly defaultOrder = NOTEBOOK_DISPLAY_ORDER,\n\t) {\n\t\tthis.order = [...new Set(initialValue)].map(pattern => ({\n\t\t\tpattern,\n\t\t\tmatches: glob.parse(normalizeSlashes(pattern))\n\t\t}));\n\t}\n\n\t/**\n\t * Returns a sorted array of the input mimetypes.\n\t */\n\tpublic sort(mimetypes: Iterable<string>): string[] {\n\t\tconst remaining = new Map(Iterable.map(mimetypes, m => [m, normalizeSlashes(m)]));\n\t\tlet sorted: string[] = [];\n\n\t\tfor (const { matches } of this.order) {\n\t\t\tfor (const [original, normalized] of remaining) {\n\t\t\t\tif (matches(normalized)) {\n\t\t\t\t\tsorted.push(original);\n\t\t\t\t\tremaining.delete(original);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remaining.size) {\n\t\t\tsorted = sorted.concat([...remaining.keys()].sort(\n\t\t\t\t(a, b) => this.defaultOrder.indexOf(a) - this.defaultOrder.indexOf(b),\n\t\t\t));\n\t\t}\n\n\t\treturn sorted;\n\t}\n\n\t/**\n\t * Records that the user selected the given mimetype over the other\n\t * possible mimetypes, prioritizing it for future reference.\n\t */\n\tpublic prioritize(chosenMimetype: string, otherMimetypes: readonly string[]) {\n\t\tconst chosenIndex = this.findIndex(chosenMimetype);\n\t\tif (chosenIndex === -1) {\n\t\t\t// always first, nothing more to do\n\t\t\tthis.order.unshift({ pattern: chosenMimetype, matches: glob.parse(normalizeSlashes(chosenMimetype)) });\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the other mimetypes that are before the chosenMimetype. Then, move\n\t\t// them after it, retaining order.\n\t\tconst uniqueIndicies = new Set(otherMimetypes.map(m => this.findIndex(m, chosenIndex)));\n\t\tuniqueIndicies.delete(-1);\n\t\tconst otherIndices = Array.from(uniqueIndicies).sort();\n\t\tthis.order.splice(chosenIndex + 1, 0, ...otherIndices.map(i => this.order[i]));\n\n\t\tfor (let oi = otherIndices.length - 1; oi >= 0; oi--) {\n\t\t\tthis.order.splice(otherIndices[oi], 1);\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of in-order mimetype preferences.\n\t */\n\tpublic toArray() {\n\t\treturn this.order.map(o => o.pattern);\n\t}\n\n\tprivate findIndex(mimeType: string, maxIndex = this.order.length) {\n\t\tconst normalized = normalizeSlashes(mimeType);\n\t\tfor (let i = 0; i < maxIndex; i++) {\n\t\t\tif (this.order[i].matches(normalized)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\tdeleteCount: number;\n}\n\nexport function diff<T>(before: T[], after: T[], contains: (a: T) => boolean, equal: (a: T, b: T) => boolean = (a: T, b: T) => a === b): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\n\t\tif (equal(beforeElement, afterElement)) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (contains(afterElement)) {\n\t\t\t// `afterElement` exists before, which means some elements before `afterElement` are deleted\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else {\n\t\t\t// `afterElement` added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport interface ICellEditorViewState {\n\tselections: editorCommon.ICursorState[];\n}\n\nexport const NOTEBOOK_EDITOR_CURSOR_BOUNDARY = new RawContextKey<'none' | 'top' | 'bottom' | 'both'>('notebookEditorCursorAtBoundary', 'none');\n\n\nexport interface INotebookLoadOptions {\n\t/**\n\t * Go to disk bypassing any cache of the model if any.\n\t */\n\tforceReadFromFile?: boolean;\n}\n\nexport interface IResolvedNotebookEditorModel extends INotebookEditorModel {\n\tnotebook: NotebookTextModel;\n}\n\nexport interface INotebookEditorModel extends IEditorModel {\n\treadonly onDidChangeDirty: Event<void>;\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeReadonly: Event<void>;\n\treadonly resource: URI;\n\treadonly viewType: string;\n\treadonly notebook: INotebookTextModel | undefined;\n\tisResolved(): this is IResolvedNotebookEditorModel;\n\tisDirty(): boolean;\n\tisReadonly(): boolean;\n\tisOrphaned(): boolean;\n\thasAssociatedFilePath(): boolean;\n\tload(options?: INotebookLoadOptions): Promise<IResolvedNotebookEditorModel>;\n\tsave(options?: ISaveOptions): Promise<boolean>;\n\tsaveAs(target: URI): Promise<IUntypedEditorInput | undefined>;\n\trevert(options?: IRevertOptions): Promise<void>;\n}\n\nexport interface INotebookDiffEditorModel extends IEditorModel {\n\toriginal: IResolvedNotebookEditorModel;\n\tmodified: IResolvedNotebookEditorModel;\n}\n\nexport interface NotebookDocumentBackupData extends IWorkingCopyBackupMeta {\n\treadonly viewType: string;\n\treadonly backupId?: string;\n\treadonly mtime?: number;\n}\n\nexport enum NotebookEditorPriority {\n\tdefault = 'default',\n\toption = 'option',\n}\n\nexport interface INotebookSearchOptions {\n\tregex?: boolean;\n\twholeWord?: boolean;\n\tcaseSensitive?: boolean;\n\twordSeparators?: string;\n\tincludeMarkupInput?: boolean;\n\tincludeMarkupPreview?: boolean;\n\tincludeCodeInput?: boolean;\n\tincludeOutput?: boolean;\n}\n\nexport interface INotebookExclusiveDocumentFilter {\n\tinclude?: string | glob.IRelativePattern;\n\texclude?: string | glob.IRelativePattern;\n}\n\nexport interface INotebookDocumentFilter {\n\tviewType?: string | string[];\n\tfilenamePattern?: string | glob.IRelativePattern | INotebookExclusiveDocumentFilter;\n}\n\n//TODO@rebornix test\n\nexport function isDocumentExcludePattern(filenamePattern: string | glob.IRelativePattern | INotebookExclusiveDocumentFilter): filenamePattern is { include: string | glob.IRelativePattern; exclude: string | glob.IRelativePattern } {\n\tconst arg = filenamePattern as INotebookExclusiveDocumentFilter;\n\n\tif ((typeof arg.include === 'string' || glob.isRelativePattern(arg.include))\n\t\t&& (typeof arg.exclude === 'string' || glob.isRelativePattern(arg.exclude))) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nexport function notebookDocumentFilterMatch(filter: INotebookDocumentFilter, viewType: string, resource: URI): boolean {\n\tif (Array.isArray(filter.viewType) && filter.viewType.indexOf(viewType) >= 0) {\n\t\treturn true;\n\t}\n\n\tif (filter.viewType === viewType) {\n\t\treturn true;\n\t}\n\n\tif (filter.filenamePattern) {\n\t\tconst filenamePattern = isDocumentExcludePattern(filter.filenamePattern) ? filter.filenamePattern.include : (filter.filenamePattern as string | glob.IRelativePattern);\n\t\tconst excludeFilenamePattern = isDocumentExcludePattern(filter.filenamePattern) ? filter.filenamePattern.exclude : undefined;\n\n\t\tif (glob.match(filenamePattern, basename(resource.fsPath).toLowerCase())) {\n\t\t\tif (excludeFilenamePattern) {\n\t\t\t\tif (glob.match(excludeFilenamePattern, basename(resource.fsPath).toLowerCase())) {\n\t\t\t\t\t// should exclude\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport interface INotebookCellStatusBarItemProvider {\n\tviewType: string;\n\tonDidChangeStatusBarItems?: Event<void>;\n\tprovideCellStatusBarItems(uri: URI, index: number, token: CancellationToken): Promise<INotebookCellStatusBarItemList | undefined>;\n}\n\n\nexport interface INotebookDiffResult {\n\tcellsDiff: IDiffResult;\n\tlinesDiff?: { originalCellhandle: number; modifiedCellhandle: number; lineChanges: ILineChange[] }[];\n}\n\nexport interface INotebookCellStatusBarItem {\n\treadonly alignment: CellStatusbarAlignment;\n\treadonly priority?: number;\n\treadonly text: string;\n\treadonly color?: string | ThemeColor;\n\treadonly backgroundColor?: string | ThemeColor;\n\treadonly tooltip?: string;\n\treadonly command?: string | Command;\n\treadonly accessibilityInformation?: IAccessibilityInformation;\n\treadonly opacity?: string;\n\treadonly onlyShowWhenActive?: boolean;\n}\n\nexport interface INotebookCellStatusBarItemList {\n\titems: INotebookCellStatusBarItem[];\n\tdispose?(): void;\n}\n\nexport type ShowCellStatusBarType = 'hidden' | 'visible' | 'visibleAfterExecute';\n\nexport const NotebookSetting = {\n\tdisplayOrder: 'notebook.displayOrder',\n\tcellToolbarLocation: 'notebook.cellToolbarLocation',\n\tcellToolbarVisibility: 'notebook.cellToolbarVisibility',\n\tshowCellStatusBar: 'notebook.showCellStatusBar',\n\ttextDiffEditorPreview: 'notebook.diff.enablePreview',\n\texperimentalInsertToolbarAlignment: 'notebook.experimental.insertToolbarAlignment',\n\tcompactView: 'notebook.compactView',\n\tfocusIndicator: 'notebook.cellFocusIndicator',\n\tinsertToolbarLocation: 'notebook.insertToolbarLocation',\n\tglobalToolbar: 'notebook.globalToolbar',\n\tundoRedoPerCell: 'notebook.undoRedoPerCell',\n\tconsolidatedOutputButton: 'notebook.consolidatedOutputButton',\n\tshowFoldingControls: 'notebook.showFoldingControls',\n\tdragAndDropEnabled: 'notebook.dragAndDropEnabled',\n\tcellEditorOptionsCustomizations: 'notebook.editorOptionsCustomizations',\n\tconsolidatedRunButton: 'notebook.consolidatedRunButton',\n\topenGettingStarted: 'notebook.experimental.openGettingStarted',\n\ttextOutputLineLimit: 'notebook.output.textLineLimit',\n\tglobalToolbarShowLabel: 'notebook.globalToolbarShowLabel',\n\tmarkupFontSize: 'notebook.markup.fontSize',\n\tinteractiveWindowCollapseCodeCells: 'interactiveWindow.collapseCellInputCode',\n\toutputLineHeight: 'notebook.outputLineHeight',\n\toutputFontSize: 'notebook.outputFontSize',\n\toutputFontFamily: 'notebook.outputFontFamily'\n} as const;\n\nexport const enum CellStatusbarAlignment {\n\tLeft = 1,\n\tRight = 2\n}\n\nexport class NotebookWorkingCopyTypeIdentifier {\n\n\tprivate static _prefix = 'notebook/';\n\n\tstatic create(viewType: string): string {\n\t\treturn `${NotebookWorkingCopyTypeIdentifier._prefix}${viewType}`;\n\t}\n\n\tstatic parse(candidate: string): string | undefined {\n\t\tif (candidate.startsWith(NotebookWorkingCopyTypeIdentifier._prefix)) {\n\t\t\treturn candidate.substring(NotebookWorkingCopyTypeIdentifier._prefix.length);\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport interface NotebookExtensionDescription {\n\treadonly id: ExtensionIdentifier;\n\treadonly location: UriComponents | undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ISequence, LcsDiff } from 'vs/base/common/diff/diff';\nimport { doHash, hash, numberHash } from 'vs/base/common/hash';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport * as model from 'vs/editor/common/model';\nimport { PieceTreeTextBufferBuilder } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder';\nimport { CellKind, ICellDto2, IMainCellDto, INotebookDiffResult, IOutputDto, NotebookCellInternalMetadata, NotebookCellMetadata, NotebookCellsChangedEventDto, NotebookCellsChangeType, NotebookCellTextModelSplice, NotebookData, NotebookDocumentMetadata } from 'vs/workbench/contrib/notebook/common/notebookCommon';\nimport { Range } from 'vs/editor/common/core/range';\nimport { INotebookWorkerHost } from 'vs/workbench/contrib/notebook/common/services/notebookWorkerHost';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\nfunction bufferHash(buffer: VSBuffer): number {\n\tlet initialHashVal = numberHash(104579, 0);\n\tfor (let k = 0; k < buffer.buffer.length; k++) {\n\t\tinitialHashVal = doHash(buffer.buffer[k], initialHashVal);\n\t}\n\n\treturn initialHashVal;\n}\n\nclass MirrorCell {\n\tprivate _textBuffer!: model.IReadonlyTextBuffer;\n\n\tget textBuffer() {\n\t\tif (this._textBuffer) {\n\t\t\treturn this._textBuffer;\n\t\t}\n\n\t\tconst builder = new PieceTreeTextBufferBuilder();\n\t\tbuilder.acceptChunk(Array.isArray(this._source) ? this._source.join('\\n') : this._source);\n\t\tconst bufferFactory = builder.finish(true);\n\t\tthis._textBuffer = bufferFactory.create(model.DefaultEndOfLine.LF).textBuffer;\n\n\t\treturn this._textBuffer;\n\t}\n\n\tprivate _primaryKey?: number | null = null;\n\tprimaryKey(): number | null {\n\t\tif (this._primaryKey === undefined) {\n\t\t\tthis._primaryKey = hash(this.getValue());\n\t\t}\n\n\t\treturn this._primaryKey;\n\t}\n\n\tprivate _hash: number | null = null;\n\n\tconstructor(\n\t\treadonly handle: number,\n\t\tprivate _source: string | string[],\n\t\tpublic language: string,\n\t\tpublic cellKind: CellKind,\n\t\tpublic outputs: IOutputDto[],\n\t\tpublic metadata?: NotebookCellMetadata,\n\t\tpublic internalMetadata?: NotebookCellInternalMetadata,\n\n\t) { }\n\n\tgetFullModelRange() {\n\t\tconst lineCount = this.textBuffer.getLineCount();\n\t\treturn new Range(1, 1, lineCount, this.textBuffer.getLineLength(lineCount) + 1);\n\t}\n\n\tgetValue(): string {\n\t\tconst fullRange = this.getFullModelRange();\n\t\tconst eol = this.textBuffer.getEOL();\n\t\tif (eol === '\\n') {\n\t\t\treturn this.textBuffer.getValueInRange(fullRange, model.EndOfLinePreference.LF);\n\t\t} else {\n\t\t\treturn this.textBuffer.getValueInRange(fullRange, model.EndOfLinePreference.CRLF);\n\t\t}\n\t}\n\n\tgetComparisonValue(): number {\n\t\tif (this._primaryKey !== null) {\n\t\t\treturn this._primaryKey!;\n\t\t}\n\n\t\tthis._hash = hash([hash(this.language), hash(this.getValue()), this.metadata, this.internalMetadata, this.outputs.map(op => ({\n\t\t\toutputs: op.outputs.map(output => ({\n\t\t\t\tmime: output.mime,\n\t\t\t\tdata: bufferHash(output.data)\n\t\t\t})),\n\t\t\tmetadata: op.metadata\n\t\t}))]);\n\t\treturn this._hash;\n\t}\n\n\tgetHashValue() {\n\t\tif (this._hash !== null) {\n\t\t\treturn this._hash;\n\t\t}\n\n\t\tthis._hash = hash([hash(this.getValue()), this.language, this.metadata, this.internalMetadata]);\n\t\treturn this._hash;\n\t}\n}\n\nclass MirrorNotebookDocument {\n\tconstructor(\n\t\treadonly uri: URI,\n\t\tpublic cells: MirrorCell[],\n\t\tpublic metadata: NotebookDocumentMetadata,\n\t) {\n\t}\n\n\tacceptModelChanged(event: NotebookCellsChangedEventDto) {\n\t\t// note that the cell content change is not applied to the MirrorCell\n\t\t// but it's fine as if a cell content is modified after the first diff, its position will not change any more\n\t\t// TODO@rebornix, but it might lead to interesting bugs in the future.\n\t\tevent.rawEvents.forEach(e => {\n\t\t\tif (e.kind === NotebookCellsChangeType.ModelChange) {\n\t\t\t\tthis._spliceNotebookCells(e.changes);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Move) {\n\t\t\t\tconst cells = this.cells.splice(e.index, 1);\n\t\t\t\tthis.cells.splice(e.newIdx, 0, ...cells);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Output) {\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.outputs = e.outputs;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellLanguage) {\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.language = e.language;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellMetadata) {\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.metadata = e.metadata;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellInternalMetadata) {\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.internalMetadata = e.internalMetadata;\n\t\t\t}\n\t\t});\n\t}\n\n\t_spliceNotebookCells(splices: NotebookCellTextModelSplice<IMainCellDto>[]) {\n\t\tsplices.reverse().forEach(splice => {\n\t\t\tconst cellDtos = splice[2];\n\t\t\tconst newCells = cellDtos.map(cell => {\n\t\t\t\treturn new MirrorCell(\n\t\t\t\t\t(cell as unknown as IMainCellDto).handle,\n\t\t\t\t\tcell.source,\n\t\t\t\t\tcell.language,\n\t\t\t\t\tcell.cellKind,\n\t\t\t\t\tcell.outputs,\n\t\t\t\t\tcell.metadata\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.cells.splice(splice[0], splice[1], ...newCells);\n\t\t});\n\t}\n}\n\nexport class CellSequence implements ISequence {\n\n\tconstructor(readonly textModel: MirrorNotebookDocument) {\n\t}\n\n\tgetElements(): string[] | number[] | Int32Array {\n\t\tconst hashValue = new Int32Array(this.textModel.cells.length);\n\t\tfor (let i = 0; i < this.textModel.cells.length; i++) {\n\t\t\thashValue[i] = this.textModel.cells[i].getComparisonValue();\n\t\t}\n\n\t\treturn hashValue;\n\t}\n\n\tgetCellHash(cell: ICellDto2) {\n\t\tconst source = Array.isArray(cell.source) ? cell.source.join('\\n') : cell.source;\n\t\tconst hashVal = hash([hash(source), cell.metadata]);\n\t\treturn hashVal;\n\t}\n}\n\nexport class NotebookEditorSimpleWorker implements IRequestHandler, IDisposable {\n\t_requestHandlerBrand: any;\n\n\tprivate _models: { [uri: string]: MirrorNotebookDocument };\n\n\tconstructor() {\n\t\tthis._models = Object.create(null);\n\t}\n\tdispose(): void {\n\t}\n\n\tpublic acceptNewModel(uri: string, data: NotebookData): void {\n\t\tthis._models[uri] = new MirrorNotebookDocument(URI.parse(uri), data.cells.map(dto => new MirrorCell(\n\t\t\t(dto as unknown as IMainCellDto).handle,\n\t\t\tdto.source,\n\t\t\tdto.language,\n\t\t\tdto.cellKind,\n\t\t\tdto.outputs,\n\t\t\tdto.metadata\n\t\t)), data.metadata);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, event: NotebookCellsChangedEventDto) {\n\t\tconst model = this._models[strURL];\n\t\tmodel?.acceptModelChanged(event);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\tcomputeDiff(originalUrl: string, modifiedUrl: string): INotebookDiffResult {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\n\t\tconst diff = new LcsDiff(new CellSequence(original), new CellSequence(modified));\n\t\tconst diffResult = diff.ComputeDiff(false);\n\n\t\t/* let cellLineChanges: { originalCellhandle: number, modifiedCellhandle: number, lineChanges: ILineChange[] }[] = [];\n\n\t\tdiffResult.changes.forEach(change => {\n\t\t\tif (change.modifiedLength === 0) {\n\t\t\t\t// deletion ...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (change.originalLength === 0) {\n\t\t\t\t// insertion\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0, len = Math.min(change.modifiedLength, change.originalLength); i < len; i++) {\n\t\t\t\tlet originalIndex = change.originalStart + i;\n\t\t\t\tlet modifiedIndex = change.modifiedStart + i;\n\n\t\t\t\tconst originalCell = original.cells[originalIndex];\n\t\t\t\tconst modifiedCell = modified.cells[modifiedIndex];\n\n\t\t\t\tif (originalCell.getValue() !== modifiedCell.getValue()) {\n\t\t\t\t\t// console.log(`original cell ${originalIndex} content change`);\n\t\t\t\t\tconst originalLines = originalCell.textBuffer.getLinesContent();\n\t\t\t\t\tconst modifiedLines = modifiedCell.textBuffer.getLinesContent();\n\t\t\t\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\t\t\t\tshouldComputeCharChanges: true,\n\t\t\t\t\t\tshouldPostProcessCharChanges: true,\n\t\t\t\t\t\tshouldIgnoreTrimWhitespace: false,\n\t\t\t\t\t\tshouldMakePrettyDiff: true,\n\t\t\t\t\t\tmaxComputationTime: 5000\n\t\t\t\t\t});\n\n\t\t\t\t\tconst lineChanges = diffComputer.computeDiff().changes;\n\n\t\t\t\t\tcellLineChanges.push({\n\t\t\t\t\t\toriginalCellhandle: originalCell.handle,\n\t\t\t\t\t\tmodifiedCellhandle: modifiedCell.handle,\n\t\t\t\t\t\tlineChanges\n\t\t\t\t\t});\n\n\t\t\t\t\t// console.log(lineDecorations);\n\n\t\t\t\t} else {\n\t\t\t\t\t// console.log(`original cell ${originalIndex} metadata change`);\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n */\n\t\treturn {\n\t\t\tcellsDiff: diffResult,\n\t\t\t// linesDiff: cellLineChanges\n\t\t};\n\t}\n\n\tprotected _getModel(uri: string): MirrorNotebookDocument {\n\t\treturn this._models[uri];\n\t}\n}\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: INotebookWorkerHost): IRequestHandler {\n\treturn new NotebookEditorSimpleWorker();\n}\n"],"mappings":"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","names":[],"file":"notebookSimpleWorker.js"}