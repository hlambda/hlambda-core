{"version":3,"sources":["out-vscode-web/vs/workbench/services/languageDetection/browser/fake","out-vscode-web/vs/workbench/services/languageDetection/browser/file:/Users/fezhang/workspace/github/github1s/vscode-web/lib/vscode/src/vs/workbench/services/languageDetection/browser/languageDetectionSimpleWorker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { ModelOperations, ModelResult } from '@vscode/vscode-languagedetection';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport { EditorSimpleWorker } from 'vs/editor/common/services/editorSimpleWorker';\nimport { IEditorWorkerHost } from 'vs/editor/common/services/editorWorkerHost';\n\ntype RegexpModel = { detect: (inp: string, langBiases: Record<string, number>, supportedLangs?: string[]) => string | undefined };\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: IEditorWorkerHost): IRequestHandler {\n\treturn new LanguageDetectionSimpleWorker(host, null);\n}\n\n/**\n * @internal\n */\nexport class LanguageDetectionSimpleWorker extends EditorSimpleWorker {\n\tprivate static readonly expectedRelativeConfidence = 0.2;\n\tprivate static readonly positiveConfidenceCorrectionBucket1 = 0.05;\n\tprivate static readonly positiveConfidenceCorrectionBucket2 = 0.025;\n\tprivate static readonly negativeConfidenceCorrection = 0.5;\n\n\tprivate _regexpModel: RegexpModel | undefined;\n\tprivate _regexpLoadFailed: boolean = false;\n\n\tprivate _modelOperations: ModelOperations | undefined;\n\tprivate _loadFailed: boolean = false;\n\n\tprivate modelIdToCoreId = new Map<string, string>();\n\n\tpublic async detectLanguage(uri: string, langBiases: Record<string, number> | undefined, preferHistory: boolean, supportedLangs?: string[]): Promise<string | undefined> {\n\t\tconst languages: string[] = [];\n\t\tconst confidences: number[] = [];\n\t\tconst stopWatch = new StopWatch(true);\n\t\tconst documentTextSample = this.getTextForDetection(uri);\n\t\tif (!documentTextSample) { return; }\n\n\t\tconst neuralResolver = async () => {\n\t\t\tfor await (const language of this.detectLanguagesImpl(documentTextSample)) {\n\t\t\t\tif (!this.modelIdToCoreId.has(language.languageId)) {\n\t\t\t\t\tthis.modelIdToCoreId.set(language.languageId, await this._host.fhr('getLanguageId', [language.languageId]));\n\t\t\t\t}\n\t\t\t\tconst coreId = this.modelIdToCoreId.get(language.languageId);\n\t\t\t\tif (coreId && (!supportedLangs?.length || supportedLangs.includes(coreId))) {\n\t\t\t\t\tlanguages.push(coreId);\n\t\t\t\t\tconfidences.push(language.confidence);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstopWatch.stop();\n\n\t\t\tif (languages.length) {\n\t\t\t\tthis._host.fhr('sendTelemetryEvent', [languages, confidences, stopWatch.elapsed()]);\n\t\t\t\treturn languages[0];\n\t\t\t}\n\t\t\treturn undefined;\n\t\t};\n\n\t\tconst historicalResolver = async () => this.runRegexpModel(documentTextSample, langBiases ?? {}, supportedLangs);\n\n\t\tif (preferHistory) {\n\t\t\tconst history = await historicalResolver();\n\t\t\tif (history) { return history; }\n\t\t\tconst neural = await neuralResolver();\n\t\t\tif (neural) { return neural; }\n\t\t} else {\n\t\t\tconst neural = await neuralResolver();\n\t\t\tif (neural) { return neural; }\n\t\t\tconst history = await historicalResolver();\n\t\t\tif (history) { return history; }\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate getTextForDetection(uri: string): string | undefined {\n\t\tconst editorModel = this._getModel(uri);\n\t\tif (!editorModel) { return; }\n\n\t\tconst end = editorModel.positionAt(10000);\n\t\tconst content = editorModel.getValueInRange({\n\t\t\tstartColumn: 1,\n\t\t\tstartLineNumber: 1,\n\t\t\tendColumn: end.column,\n\t\t\tendLineNumber: end.lineNumber\n\t\t});\n\t\treturn content;\n\t}\n\n\tprivate async getRegexpModel(): Promise<RegexpModel | undefined> {\n\t\tif (this._regexpLoadFailed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._regexpModel) {\n\t\t\treturn this._regexpModel;\n\t\t}\n\t\tconst uri: string = await this._host.fhr('getRegexpModelUri', []);\n\t\ttry {\n\t\t\tthis._regexpModel = await import(uri) as RegexpModel;\n\t\t\treturn this._regexpModel;\n\t\t} catch (e) {\n\t\t\tthis._regexpLoadFailed = true;\n\t\t\t// console.warn('error loading language detection model', e);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate async runRegexpModel(content: string, langBiases: Record<string, number>, supportedLangs?: string[]): Promise<string | undefined> {\n\t\tconst regexpModel = await this.getRegexpModel();\n\t\tif (!regexpModel) { return; }\n\n\t\tif (supportedLangs?.length) {\n\t\t\t// When using supportedLangs, normally computed biases are too extreme. Just use a \"bitmask\" of sorts.\n\t\t\tfor (const lang of Object.keys(langBiases)) {\n\t\t\t\tif (supportedLangs.includes(lang)) {\n\t\t\t\t\tlangBiases[lang] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlangBiases[lang] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst detected = regexpModel.detect(content, langBiases, supportedLangs);\n\t\treturn detected;\n\t}\n\n\tprivate async getModelOperations(): Promise<ModelOperations> {\n\t\tif (this._modelOperations) {\n\t\t\treturn this._modelOperations;\n\t\t}\n\n\t\tconst uri: string = await this._host.fhr('getIndexJsUri', []);\n\t\tconst { ModelOperations } = await import(uri) as typeof import('@vscode/vscode-languagedetection');\n\t\tthis._modelOperations = new ModelOperations({\n\t\t\tmodelJsonLoaderFunc: async () => {\n\t\t\t\tconst response = await fetch(await this._host.fhr('getModelJsonUri', []));\n\t\t\t\ttry {\n\t\t\t\t\tconst modelJSON = await response.json();\n\t\t\t\t\treturn modelJSON;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconst message = `Failed to parse model JSON.`;\n\t\t\t\t\tthrow new Error(message);\n\t\t\t\t}\n\t\t\t},\n\t\t\tweightsLoaderFunc: async () => {\n\t\t\t\tconst response = await fetch(await this._host.fhr('getWeightsUri', []));\n\t\t\t\tconst buffer = await response.arrayBuffer();\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t});\n\n\t\treturn this._modelOperations!;\n\t}\n\n\t// This adjusts the language confidence scores to be more accurate based on:\n\t// * VS Code's language usage\n\t// * Languages with 'problematic' syntaxes that have caused incorrect language detection\n\tprivate adjustLanguageConfidence(modelResult: ModelResult): ModelResult {\n\t\tswitch (modelResult.languageId) {\n\t\t\t// For the following languages, we increase the confidence because\n\t\t\t// these are commonly used languages in VS Code and supported\n\t\t\t// by the model.\n\t\t\tcase 'js':\n\t\t\tcase 'html':\n\t\t\tcase 'json':\n\t\t\tcase 'ts':\n\t\t\tcase 'css':\n\t\t\tcase 'py':\n\t\t\tcase 'xml':\n\t\t\tcase 'php':\n\t\t\t\tmodelResult.confidence += LanguageDetectionSimpleWorker.positiveConfidenceCorrectionBucket1;\n\t\t\t\tbreak;\n\t\t\t// case 'yaml': // YAML has been know to cause incorrect language detection because the language is pretty simple. We don't want to increase the confidence for this.\n\t\t\tcase 'cpp':\n\t\t\tcase 'sh':\n\t\t\tcase 'java':\n\t\t\tcase 'cs':\n\t\t\tcase 'c':\n\t\t\t\tmodelResult.confidence += LanguageDetectionSimpleWorker.positiveConfidenceCorrectionBucket2;\n\t\t\t\tbreak;\n\n\t\t\t// For the following languages, we need to be extra confident that the language is correct because\n\t\t\t// we've had issues like #131912 that caused incorrect guesses. To enforce this, we subtract the\n\t\t\t// negativeConfidenceCorrection from the confidence.\n\n\t\t\t// languages that are provided by default in VS Code\n\t\t\tcase 'bat':\n\t\t\tcase 'ini':\n\t\t\tcase 'makefile':\n\t\t\tcase 'sql':\n\t\t\t// languages that aren't provided by default in VS Code\n\t\t\tcase 'csv':\n\t\t\tcase 'toml':\n\t\t\t\t// Other considerations for negativeConfidenceCorrection that\n\t\t\t\t// aren't built in but suported by the model include:\n\t\t\t\t// * Assembly, TeX - These languages didn't have clear language modes in the community\n\t\t\t\t// * Markdown, Dockerfile - These languages are simple but they embed other languages\n\t\t\t\tmodelResult.confidence -= LanguageDetectionSimpleWorker.negativeConfidenceCorrection;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn modelResult;\n\t}\n\n\tprivate async * detectLanguagesImpl(content: string): AsyncGenerator<ModelResult, void, unknown> {\n\t\tif (this._loadFailed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet modelOperations: ModelOperations | undefined;\n\t\ttry {\n\t\t\tmodelOperations = await this.getModelOperations();\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t\tthis._loadFailed = true;\n\t\t\treturn;\n\t\t}\n\n\t\tlet modelResults: ModelResult[] | undefined;\n\n\t\ttry {\n\t\t\tmodelResults = await modelOperations.runModel(content);\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t}\n\n\t\tif (!modelResults\n\t\t\t|| modelResults.length === 0\n\t\t\t|| modelResults[0].confidence < LanguageDetectionSimpleWorker.expectedRelativeConfidence) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstModelResult = this.adjustLanguageConfidence(modelResults[0]);\n\t\tif (firstModelResult.confidence < LanguageDetectionSimpleWorker.expectedRelativeConfidence) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst possibleLanguages: ModelResult[] = [firstModelResult];\n\n\t\tfor (let current of modelResults) {\n\t\t\tif (current === firstModelResult) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrent = this.adjustLanguageConfidence(current);\n\t\t\tconst currentHighest = possibleLanguages[possibleLanguages.length - 1];\n\n\t\t\tif (currentHighest.confidence - current.confidence >= LanguageDetectionSimpleWorker.expectedRelativeConfidence) {\n\t\t\t\twhile (possibleLanguages.length) {\n\t\t\t\t\tyield possibleLanguages.shift()!;\n\t\t\t\t}\n\t\t\t\tif (current.confidence > LanguageDetectionSimpleWorker.expectedRelativeConfidence) {\n\t\t\t\t\tpossibleLanguages.push(current);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (current.confidence > LanguageDetectionSimpleWorker.expectedRelativeConfidence) {\n\t\t\t\t\tpossibleLanguages.push(current);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"AAAA;;4DAAA,AAAA,WAAA,CACA,GAAA,GAAA,CAAA,gFAAA,UAAA,UAAA,2BAAA,gDACA,EAAA,SAAA,EAAA,CAEA,OADA,GAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IACA,EAAA,GAAA,EAAA,EAAA,IAEA,MAAA,6JCUA,WAAuB,EAAuB,CAC7C,MAAO,IAAI,GAA8B,EAAM,MADhD,EAAA,OAAA,EAOA,eAAmD,GAAA,kBAAkB,CAArE,aAAA,qBAOS,KAAA,kBAA6B,GAG7B,KAAA,YAAuB,GAEvB,KAAA,gBAAkB,GAAI,UAEjB,gBAAe,EAAa,EAAgD,EAAwB,EAAyB,CACzI,KAAM,GAAsB,GACtB,EAAwB,GACxB,EAAY,GAAI,GAAA,UAAU,IAC1B,EAAqB,KAAK,oBAAoB,GACpD,GAAI,CAAC,EAAsB,OAE3B,KAAM,GAAiB,SAAW,CACjC,eAAiB,KAAY,MAAK,oBAAoB,GAAqB,CAC1E,AAAK,KAAK,gBAAgB,IAAI,EAAS,aACtC,KAAK,gBAAgB,IAAI,EAAS,WAAY,KAAM,MAAK,MAAM,IAAI,gBAAiB,CAAC,EAAS,cAE/F,KAAM,GAAS,KAAK,gBAAgB,IAAI,EAAS,YACjD,AAAI,GAAW,EAAC,GAAgB,QAAU,EAAe,SAAS,KACjE,GAAU,KAAK,GACf,EAAY,KAAK,EAAS,aAK5B,GAFA,EAAU,OAEN,EAAU,OACb,YAAK,MAAM,IAAI,qBAAsB,CAAC,EAAW,EAAa,EAAU,YACjE,EAAU,IAKb,EAAqB,SAAY,KAAK,eAAe,EAAoB,GAAc,GAAI,GAEjG,GAAI,EAAe,CAClB,KAAM,GAAU,KAAM,KACtB,GAAI,EAAW,MAAO,GACtB,KAAM,GAAS,KAAM,KACrB,GAAI,EAAU,MAAO,OACf,CACN,KAAM,GAAS,KAAM,KACrB,GAAI,EAAU,MAAO,GACrB,KAAM,GAAU,KAAM,KACtB,GAAI,EAAW,MAAO,IAMhB,oBAAoB,EAAW,CACtC,KAAM,GAAc,KAAK,UAAU,GACnC,GAAI,CAAC,EAAe,OAEpB,KAAM,GAAM,EAAY,WAAW,KAOnC,MANgB,GAAY,gBAAgB,CAC3C,YAAa,EACb,gBAAiB,EACjB,UAAW,EAAI,OACf,cAAe,EAAI,kBAKP,iBAAc,CAC3B,GAAI,KAAK,kBACR,OAED,GAAI,KAAK,aACR,MAAO,MAAK,aAEb,KAAM,GAAc,KAAM,MAAK,MAAM,IAAI,oBAAqB,IAC9D,GAAI,CACH,YAAK,aAAe,KAAA,IAAA,SAAA,CAAA,EAAA,IAAA,CAAA,EAAA,CAAa,GAAG,EAAA,KAC7B,KAAK,kBACX,CACD,KAAK,kBAAoB,GAEzB,aAIY,gBAAe,EAAiB,EAAoC,EAAyB,CAC1G,KAAM,GAAc,KAAM,MAAK,iBAC/B,GAAI,CAAC,EAAe,OAEpB,GAAI,GAAgB,OAEnB,SAAW,KAAQ,QAAO,KAAK,GAC9B,AAAI,EAAe,SAAS,GAC3B,EAAW,GAAQ,EAEnB,EAAW,GAAQ,EAMtB,MADiB,GAAY,OAAO,EAAS,EAAY,QAI5C,qBAAkB,CAC/B,GAAI,KAAK,iBACR,MAAO,MAAK,iBAGb,KAAM,GAAc,KAAM,MAAK,MAAM,IAAI,gBAAiB,IACpD,CAAE,mBAAoB,KAAA,IAAA,SAAA,CAAA,EAAA,IAAA,CAAA,EAAA,CAAa,GAAG,EAAA,KAC5C,YAAK,iBAAmB,GAAI,GAAgB,CAC3C,oBAAqB,SAAW,CAC/B,KAAM,GAAW,KAAM,OAAM,KAAM,MAAK,MAAM,IAAI,kBAAmB,KACrE,GAAI,CAEH,MADkB,MAAM,GAAS,YAEhC,CACD,KAAM,GAAU,8BAChB,KAAM,IAAI,OAAM,KAGlB,kBAAmB,SAEH,KAAM,AADJ,MAAM,OAAM,KAAM,MAAK,MAAM,IAAI,gBAAiB,MACrC,gBAKzB,KAAK,iBAML,yBAAyB,EAAwB,CACxD,OAAQ,EAAY,gBAId,SACA,WACA,WACA,SACA,UACA,SACA,UACA,MACJ,EAAY,YAAc,EAA8B,oCACxD,UAEI,UACA,SACA,WACA,SACA,IACJ,EAAY,YAAc,EAA8B,oCACxD,UAOI,UACA,UACA,eACA,UAEA,UACA,OAKJ,EAAY,YAAc,EAA8B,6BACxD,cAGA,MAGF,MAAO,SAGQ,oBAAoB,EAAe,CAClD,GAAI,KAAK,YACR,OAGD,GAAI,GACJ,GAAI,CACH,EAAkB,KAAM,MAAK,2BACrB,EAAP,CACD,QAAQ,IAAI,GACZ,KAAK,YAAc,GACnB,OAGD,GAAI,GAEJ,GAAI,CACH,EAAe,KAAM,GAAgB,SAAS,SACtC,EAAP,CACD,QAAQ,KAAK,GAGd,GAAI,CAAC,GACD,EAAa,SAAW,GACxB,EAAa,GAAG,WAAa,EAA8B,2BAC9D,OAGD,KAAM,GAAmB,KAAK,yBAAyB,EAAa,IACpE,GAAI,EAAiB,WAAa,EAA8B,2BAC/D,OAGD,KAAM,GAAmC,CAAC,GAE1C,OAAS,KAAW,GAAc,CACjC,GAAI,IAAY,EACf,SAMD,GAHA,EAAU,KAAK,yBAAyB,GAGpC,AAFmB,EAAkB,EAAkB,OAAS,GAEjD,WAAa,EAAQ,YAAc,EAA8B,2BAA4B,CAC/G,KAAO,EAAkB,QACxB,KAAM,GAAkB,QAEzB,GAAI,EAAQ,WAAa,EAA8B,2BAA4B,CAClF,EAAkB,KAAK,GACvB,SAED,WACM,CACN,GAAI,EAAQ,WAAa,EAA8B,2BAA4B,CAClF,EAAkB,KAAK,GACvB,SAED,UAvPJ,EAAA,8BAAA,EACyB,EAAA,2BAA6B,GAC7B,EAAA,oCAAsC,IACtC,EAAA,oCAAsC,KACtC,EAAA,6BAA+B,OD5BxD,KAAA","names":[],"file":"languageDetectionSimpleWorker.js"}